# Controller Area Network \(CAN\)

The Controller Area Network with Flexible Data-rate \(CAN FD\) module<br />supports the following key features:

Standards Compliance:

-   Full CAN 2.0B compliance

-   Programmable bit rate

-   ISO118981:2015 plus CAN FD 1.0 compliant, supports up to 64<br />data bytes payload/message

-   Arbitration Bit Rate up to one Mbps

-   FD Bit Rate up to eight Mbps<br />Message Reception and Transmission:

-   32 message FIFOs

-   Each FIFO can have up to 32 messages for a total of 512 messages

-   FIFO can be a transmit message FIFO or a receive message FIFO

-   Userdefined priority levels for message FIFOs used for<br />transmission

-   32 acceptance filters for message filtering

-   32 acceptance filter mask registers for message filtering

-   Automatic response to Remote Transmit Request \(RTR\)


**Using The Library**

The CAN library supports the CAN FD and CAN Classic \(Normal\) mode. The<br />CAN FD and CAN Classic \(Normal\) mode can transfer message in a polling<br />or an interrupt mode.

**CAN FD operation with polling**

The following example shows the CAN FD mode operation with polling<br />implementation.

```c
void print_menu(void)

{

printf("Menu :\\r\\n"

" -- Select the action:\\r\\n"

" 1: Send FD standard message with ID: 0x45A and 64 byte data 0 to 63.
\\r\\n"

" 2: Send normal standard message with ID: 0x469 and 8 byte data 0 to
\7. \\r\\n"

" 3: To receive CAN FD or Normal message \\r\\n"

" m: Display menu \\r\\n\\r\\n");

}



int main ( void )
{

uint32_t messageID = 0;

uint32_t rx_messageID = 0;

uint32_t status = 0;

uint8_t messageLength = 0;

uint8_t rx_messageLength = 0;

uint8_t count = 0;

uint8_t user_input = 0;

CANFD_MSG_RX_ATTRIBUTE msgAttr = CANFD_MSG_RX_DATA_FRAME;



/* Initialize all modules */

SYS_Initialize ( NULL );



printf(" ------------------------------ \\r\\n");

printf(" CAN FD Demo \\r\\n");

printf(" ------------------------------ \\r\\n");



print_menu();



/* Prepare the message to send*/

for (count = 0; count \< 64; count++)

{

message[count] = count;

}



while ( true )

{

/* Maintain state machines of all polled Harmony modules. */

/* Check if there is a received character */

if(UART2_ReceiverIsReady() == true)

{

if(UART2_ErrorGet() == UART_ERROR_NONE)

{

UART2_Read((void *)&amp;user_input, 1);

}

switch (user_input)

{

case '1':

printf(" Transmitting CAN FD Message:");

messageID = 0x45A;

messageLength = 64;

if (CAN1_MessageTransmit(messageID, messageLength, message, 1,
CANFD_MODE_FD_WITH_BRS, CANFD_MSG_TX_DATA_FRAME) == true)

{

printf("Success \\r\\n");

LED_Toggle();

}

else

{

printf("Failed \\r\\n");

}

break;

case '2':

printf(" Transmitting CAN Normal Message:");

messageID = 0x469;

messageLength = 8;

if (CAN1_MessageTransmit(messageID, messageLength, message, 1,
CANFD_MODE_NORMAL, CANFD_MSG_TX_DATA_FRAME) == true)

{

printf("Success \\r\\n");

LED_Toggle();

}

else

{

printf("Failed \\r\\n");

}

break;

case '3':

printf(" Waiting for message: \\r\\n");

while (true)

{

if (CAN1_InterruptGet(2, CANFD_FIFO_INTERRUPT_TFNRFNIF_MASK))

{

/* Check CAN Status */

status = CAN1_ErrorGet();



if (status == CANFD_ERROR_NONE)

{

memset(rx_message, 0x00, sizeof(rx_message));



/* Receive New Message */

if (CAN1_MessageReceive(&amp;rx_messageID, &amp;rx_messageLength,
rx_message, 0, 2, &amp;msgAttr) == true)

{

printf(" New Message Received \\r\\n");

status = CAN1_ErrorGet();

if (status == CANFD_ERROR_NONE)

{

/* Print message to Console */

uint8_t length = rx_messageLength;

printf(" Message - ID : 0x%x Length : 0x%x ", (unsigned int)
rx_messageID,(unsigned int) rx_messageLength);

printf("Message : ");

while(length)

{

printf("0x%x ", rx_message[rx_messageLength - length--]);

}

printf("\\r\\n");

LED_Toggle();

break;

}

else

{

printf("Error in received message");

}

}

else

{

printf("Message Reception Failed \\r");

}

}

else

{

printf("Error in last received message");

}

}

}

break;

default:

printf(" Invalid Input \\r\\n");

break;

}

print_menu();

}

}



/* Execution should not come here during normal operation */



return ( EXIT_FAILURE );

}
```

**CAN FD operation with interrupt**

The following example shows the CAN FD mode operation with interrupt<br />implementation.

```c
/* Application's state machine enum */

typedef enum

{

APP_STATE_CAN_RECEIVE,

APP_STATE_CAN_TRANSMIT,

APP_STATE_CAN_IDLE,

APP_STATE_CAN_USER_INPUT,

APP_STATE_CAN_XFER_SUCCESSFUL,

APP_STATE_CAN_XFER_ERROR

} APP_STATES;



/* Variable to save application state */

static APP_STATES state = APP_STATE_CAN_USER_INPUT;



void APP_CAN_Callback(uintptr_t context)

{

xferContext = context;



/* Check CAN Status */

status = CAN1_ErrorGet();



if ((status &amp; (CANFD_ERROR_TX_RX_WARNING_STATE |
CANFD_ERROR_RX_WARNING_STATE |

CANFD_ERROR_TX_WARNING_STATE | CANFD_ERROR_RX_BUS_PASSIVE_STATE |

CANFD_ERROR_TX_BUS_PASSIVE_STATE | CANFD_ERROR_TX_BUS_OFF_STATE)) ==
CANFD_ERROR_NONE)

{

switch ((APP_STATES)context)

{

case APP_STATE_CAN_RECEIVE:

case APP_STATE_CAN_TRANSMIT:

{

state = APP_STATE_CAN_XFER_SUCCESSFUL;

break;

}

default:

break;

}

}

else

{

state = APP_STATE_CAN_XFER_ERROR;

}

}



int main ( void )
{

uint8_t count = 0;

bool user_input = 0;



/* Initialize all modules */

SYS_Initialize ( NULL );



/* Prepare the message to send*/

messageID = 0x45A;

messageLength = 64;

for (count = 0; count \< 64; count++)

{

message[count] = count;

}



while ( true )

{

if (state == APP_STATE_CAN_USER_INPUT)

{

if(SWITCH_Get() == SWITCH_PRESSED_STATE)

{

while(SWITCH_Get() == SWITCH_PRESSED_STATE);



switch (user_input)

{

case 0:

CAN1_CallbackRegister( APP_CAN_Callback,
(uintptr_t)APP_STATE_CAN_TRANSMIT, 1 );

state = APP_STATE_CAN_IDLE;

CAN1_MessageTransmit(messageID, messageLength, message, 1,
CANFD_MODE_FD_WITH_BRS, CANFD_MSG_TX_DATA_FRAME);

break;

case 1:

CAN1_CallbackRegister( APP_CAN_Callback,
(uintptr_t)APP_STATE_CAN_RECEIVE, 2 );

state = APP_STATE_CAN_IDLE;

memset(rx_message, 0x00, sizeof(rx_message));

/* Receive New Message */

CAN1_MessageReceive(&amp;rx_messageID, &amp;rx_messageLength, rx_message,
0, 2, &amp;msgAttr);

break;

default:

break;

}

}

else

{

continue;

}

}

/* Check the application's current state. */

switch (state)

{

case APP_STATE_CAN_IDLE:

{

/* Application can do other task here */

break;

}

case APP_STATE_CAN_XFER_SUCCESSFUL:

{

if ((APP_STATES)xferContext == APP_STATE_CAN_RECEIVE)

{

}

else if ((APP_STATES)xferContext == APP_STATE_CAN_TRANSMIT)

{

}

LED_Toggle();

state = APP_STATE_CAN_USER_INPUT;

break;

}

case APP_STATE_CAN_XFER_ERROR:

{

if ((APP_STATES)xferContext == APP_STATE_CAN_RECEIVE)

{

}

else

{

}

state = APP_STATE_CAN_USER_INPUT;

break;

}

default:

break;

}



}



/* Execution should not come here during normal operation */



return ( EXIT_FAILURE );
}
```

**Library Interface**

peripheral library provides the following interfaces:

**Functions**

|Name|Description|
|----|-----------|
|CANx\_Initialize|Initializes given instance of the CAN peripheral|
|CANx\_MessageTransmit|Transmits a message into CAN bus|
|CANx\_MessageReceive|Receives a message from CAN bus|
|CANx\_MessageAbort|Abort request for a FIFO|
|CANx\_MessageAcceptanceFilterSet|Set Message acceptance filter configuration|
|CANx\_MessageAcceptanceFilterGet|Get Message acceptance filter configuration|
|CANx\_MessageAcceptanceFilterMaskSet|Set Message acceptance filter mask configuration|
|CANx\_MessageAcceptanceFilterMaskGet|Get Message acceptance filter mask configuration|
|CANx\_TransmitEventFIFOElementGet|Get the Transmit Event FIFO Element for the transmitted message|
|CANx\_ErrorGet|Returns the error during transfer|
|CANx\_ErrorCountGet|Returns the transmit and receive error count during transfer|
|CANx\_InterruptGet|Returns the FIFO Interrupt status|
|CANx\_TxFIFOQueueIsFull|Returns true if Tx FIFO/Queue is full otherwise false|
|CANx\_AutoRTRResponseSet|Set the Auto RTR response for remote transmit request|
|CANx\_CallbackRegister|Sets the pointer to the function \(and it's context\) to be called when the given CAN's transfer events occur|
|CANx\_ErrorCallbackRegister|Sets the pointer to the function \(and it's context\) to be called when error occurs in CAN|

**Data types and constants**

|Name|Type|Description|
|----|----|-----------|
|CANFD\_MODE|Enum|CANFD Mode for Classic CAN and CAN FD|
|CANFD\_MSG\_TX\_ATTRIBUTE|Enum|CANFD Tx Message Attribute for Tx FIFO and Tx Queue|
|CANFD\_MSG\_RX\_ATTRIBUTE|Enum|CANFD Message RX Attribute for Data Frame and Remote Frame|
|CANFD\_FIFO\_INTERRUPT\_FLAG\_MASK|Enum|CANFD FIFO Interrupt Status Flag Mask|
|CANFD\_ERROR|Enum|CANFD Transfer Error data type|
|CANFD\_CALLBACK|Typedef|CANFD Callback Function Pointer|
|CANFD\_RX\_MSG|Struct|CANFD RX Message Buffer structure|
|CANFD\_RX\_MSG\_OBJECT|Struct|CANFD Receive Message Object structure|
|CANFD\_TX\_MSG\_OBJECT|Struct|CANFD Transmit Message Object structure|
|CANFD\_TX\_EVENT\_FIFO\_ELEMENT|Struct|CANFD Trasmit Event FIFO Element structure|

-   **[CANx\_Initialize Function](GUID-3E146A1F-2790-4E35-9A57-92D94CDA1B7A.md)**  

-   **[CANx\_MessageTransmit Function](GUID-F8FB08F1-1020-4E0E-B699-D668F76EE4CC.md)**  

-   **[CANx\_MessageReceive Function](GUID-AB451CE2-D96C-445A-8F97-8B9565AB2BF7.md)**  

-   **[CANx\_MessageAbort Function](GUID-4E46CDAF-9154-41A4-A3E5-F3534521CF18.md)**  

-   **[CANx\_MessageAcceptanceFilterSet Function](GUID-2CBE4110-28DB-4C92-9465-5C4ACBF3FFC8.md)**  

-   **[CANx\_MessageAcceptanceFilterGet Function](GUID-6E337100-32F5-4051-A12E-D4C576015217.md)**  

-   **[CANx\_MessageAcceptanceFilterMaskSet Function](GUID-7B95D5B8-25D8-4247-8258-8C3FA75213B9.md)**  

-   **[CANx\_MessageAcceptanceFilterMaskGet Function](GUID-A9950957-48E0-4BEE-974D-800D95896821.md)**  

-   **[CANx\_TransmitEventFIFOElementGet Function](GUID-72AC3C8A-F49E-4937-893E-26023650FCD8.md)**  

-   **[CANx\_ErrorGet Function](GUID-132D09D6-406E-49B7-893E-81AC3DA848DF.md)**  

-   **[CANx\_ErrorCountGet Function](GUID-C47468D6-2A6E-41E6-B936-72567DF52D2B.md)**  

-   **[CANx\_InterruptGet Function](GUID-403171E7-428F-41E9-99DB-0EAF210A1BB4.md)**  

-   **[CANx\_TxFIFOQueueIsFull Function](GUID-4187B6B7-CEE0-48C8-86A0-ED31452B0933.md)**  

-   **[CANx\_AutoRTRResponseSet Function](GUID-FC5C258E-482B-442B-B10D-5855D6D16986.md)**  

-   **[CANx\_CallbackRegister Function](GUID-46738CBF-1F53-47EC-A81A-378A7C4CA22C.md)**  

-   **[CANx\_ErrorCallbackRegister Function](GUID-8E1F4F48-8DEC-4654-BC98-64CD90BFA9B6.md)**  

-   **[CANFD\_MODE Enum](GUID-9FE389A0-5D11-49A8-9132-76EDAF805D10.md)**  

-   **[CANFD\_MSG\_TX\_ATTRIBUTE Enum](GUID-2C1EFB73-59F9-4AC8-BE78-4B390FF85C5F.md)**  

-   **[CANFD\_MSG\_RX\_ATTRIBUTE Enum](GUID-57193D07-75D5-4EF3-BFB3-2DA164653748.md)**  

-   **[CANFD\_FIFO\_INTERRUPT\_FLAG\_MASK Enum](GUID-2FDCC4B9-AD99-4BEB-B6A9-00673720FF81.md)**  

-   **[CANFD\_ERROR Enum](GUID-8693E652-67FB-4B4F-AC18-6256B258FC78.md)**  

-   **[CANFD\_CALLBACK Typedef](GUID-6B701775-3142-44F7-8D25-90D74B3FDCB9.md)**  

-   **[CANFD\_RX\_MSG Struct](GUID-4F8CEFF2-877B-4A5B-BEC9-B592D121322B.md)**  

-   **[CANFD\_RX\_MSG\_OBJECT Struct](GUID-6BF39B2B-852C-4430-A6B4-CC5E9BED49D3.md)**  

-   **[CANFD\_TX\_MSG\_OBJECT Struct](GUID-FF3501D7-0EC6-4A5A-9673-AE1806FC077D.md)**  

-   **[CANFD\_TX\_EVENT\_FIFO\_ELEMENT Struct](GUID-09A87033-DE0F-4F46-9CD2-873785251021.md)**  


**Parent topic:**[PIC32MK GPG MCJ Peripheral Libraries](GUID-A0350A48-03F7-4370-A6C5-612386A4ABAC.md)

**Parent topic:**[PIC32MK GPK MCM Peripheral Libraries](GUID-801B9DE7-4616-4E38-BF86-C82B78A4F430.md)

**Parent topic:**[PIC32MZ W1 Peripheral Libraries](GUID-EBD28D67-7F6E-46D1-9ABE-2BDE1973D143.md)

