<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html
  PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />

<meta http-equiv="X-UA-Compatible" content="IE=EmulateIE11" /><meta name="copyright" content="(C) Copyright 2022" />
<meta name="DC.rights.owner" content="(C) Copyright 2022" />
<meta name="DC.type" content="topic" />
<meta name="DC.title" content="SERCOMx_I2C_LastByteAckStatusGet Function" />
<meta name="DC.format" content="XHTML" />
<meta name="DC.identifier" content="sercomx-i2c-lastbyteackstatusget-function" />
<link rel="stylesheet" type="text/css" href="stylesheets/commonltr.css" />
<link rel="stylesheet" type="text/css" href="stylesheets/atmel.css" />
<link rel="stylesheet" type="text/css" href="./stylesheets/common-extended.css" /><title>SERCOMx_I2C_LastByteAckStatusGet Function</title>
<meta name="Microsoft.Help.Id" content="GUID-1EA9B250-D935-443A-9FA9-C48E50D229E8-sercomx-i2c-lastbyteackstatusget-function" />
<meta name="Microsoft.Help.TocParent" content="GUID-1EA9B250-D935-443A-9FA9-C48E50D229E8" />
<meta name="Microsoft.Help.TocOrder" content="0" />
<meta name="Microsoft.Help.Locale" content="en-US" />
<meta name="Microsoft.Help.TopicLocale" content="en-US" />
<meta name="Microsoft.Help.DisplayVersion" content="MPLABÂ® Harmony Peripheral Libraries Reference A 09/2021" />
<script language="javascript">
       
       if (window.parent.location.protocol != 'file:') {
				document.addEventListener('click', function(e) {
				    if (e.target) {
               if (e.target.nodeName == "A" ) {
                    if (!e.target.target) {
                      e.preventDefault();
                      e.stopPropagation();
                              
                      var origUrl = window.parent.location.href.substr(0, window.parent.location.href.indexOf("?"));
                      if (origUrl.length === 0) {
                          origUrl = window.parent.location.href;
                      }
                      var href= e.target.getAttribute("href");
                      var parts = href.split("#");
          
                      var url = "";
                      if (parts.length == 2 ) {
                        if (!parts[0].length) {
                            url = window.parent.location.search.replace('?','')
                        } else {
                            url = parts[0].replace('.html','');
                        }
                      } else {
                        url = parts[0].replace('.html','');
                      }

                      if (parts.length == 2) {
                          url += "#" + parts[1];
                      }
    
                      window.parent.location.href = origUrl + "?" + url;

                      return false;
                    }
               }
            }
				});
			}

		</script><script language="javascript">
        function cpy(id, button) {
        
            var element = document.getElementById(id);
            var content = element.getAttribute("content");
            var textArea = document.createElement("textarea");
            
            // Place in the top-left corner of screen regardless of scroll position.
            textArea.style.position = 'fixed';
            textArea.style.top = 0;
            textArea.style.left = 0;
            
            // Ensure it has a small width and height. Setting to 1px / 1em
            // doesn't work as this gives a negative w/h on some browsers.
            textArea.style.width = '2em';
            textArea.style.height = '2em';
            
            // We don't need padding, reducing the size if it does flash render.
            textArea.style.padding = 0;
            
            // Clean up any borders.
            textArea.style.border = 'none';
            textArea.style.outline = 'none';
            textArea.style.boxShadow = 'none';
            
            // Avoid flash of the white box if rendered for any reason.
            textArea.style.background = 'transparent';
            
            
            textArea.value = content;
            
            document.body.appendChild(textArea);
            textArea.focus();
            textArea.select();
            
            try {
               var successful = document.execCommand('copy');
               var msg = successful ? 'successful' : 'unsuccessful';
               if (!button.classList.contains("copied")){
                  button.textContent = "Copied";
                  button.classList.add("copied");
                  setTimeout(function(){
                    button.textContent = "Copy";
                    button.classList.remove("copied");
                  },1000);
               }
            } catch (err) {
              console.log('Oops, unable to copy');
            }
            
            document.body.removeChild(textArea);
        }
      </script><script language="javascript">
          
          // Add the MathML namespace to html
          var html = document.getElementsByTagName("html")[0],
          head = document.getElementsByTagName("head")[0];
          
          var mathJax = document.createElement("script");
          mathJax.src = "https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-MML-AM_CHTML";
          head.appendChild(mathJax);
          
          html.setAttribute("xmlns:m","http://www.w3.org/1998/Math/MathML");
          
          function inIframe() { try { return window.self !== window.top; } catch (e) { return true; } }
          
          if (!inIframe()) { 
          
          var Default = "index.html?GUID-74BC0AA9-58D6-4484-901E-E4CFFF3FC9F9"; 
          
          var displaylocation = "value" + window.location.href;
          
          var GUIDS = displaylocation.split('GUID');          
          
          if (displaylocation.indexOf('#GUID') != -1) {            
          var First = GUIDS[1].split('.html');  
          if (GUIDS[3]){First = GUIDS[2].split('.html');}
          if (GUIDS[4]){First = GUIDS[3].split('.html');}
          if (GUIDS[5]){First = GUIDS[4].split('.html');}
          
          var Second = GUIDS[2].split('#');   
          if (GUIDS[3]){Second = GUIDS[3].split('#');}
          if (GUIDS[4]){Second = GUIDS[4].split('#');}
          if (GUIDS[5]){Second = GUIDS[5].split('#');}
          
          Default = "index.html?" + "GUID" + First[0] + "GUID" + Second[0];     
          }                    
          window.top.location = Default;
          }       
          
        </script><style xml:space="">
        
          button.copy-code{
            display:none;
            padding:0.7em 1.4em;
            margin:0 0.3em 0.3em 0;
            border-radius:0.15em;
            box-sizing: border-box;
            text-decoration:none;
            font-family:'Roboto',sans-serif;
            text-transform:uppercase;
            font-weight:400;
            color:#FFFFFF;
            background-color:#9c9c9c;
            box-shadow:inset 0 -0.6em 0 -0.35em rgba(0,0,0,0.17);
            text-align:center;
            position:relative;
            border: 0;
            float: right;
            border-radius: .5em;
            cursor: pointer;
          }
          button.copy-code:active{
            top:0.1em;
          }
          
          pre:hover button.copy-code{
            display: inline-block !important;
          }
          button.copy-code.copied {
            cursor: default !important;
          }
          
          
          @media all and (max-width:30em){
            button.copy-code{
              display:block;
              margin:0.4em auto;
            }
          }
        
        
      </style></head>
<body id="sercomx-i2c-lastbyteackstatusget-function">
<h1 class="title topictitle1" id="ariaid-title1">SERCOMx_I2C_LastByteAckStatusGet Function</h1><div class="body"></div>
<div class="topic nested1" aria-labelledby="ariaid-title2" id="c"><h2 class="title topictitle2" id="ariaid-title2">C</h2><div class="body"><pre class="pre codeblock language-c"><button title="Copy Code" class="copy-code" onclick="cpy('d569895e14', this);">Copy</button><code id="d569895e14" content="/* x = SERCOM instance number */&#xA;&#xA;/* I2C slave mode */&#xA;&#xA;SERCOM_I2C_SLAVE_ACK_STATUS SERCOMx_I2C_LastByteAckStatusGet(void)&#x9;"><span class="ph token comment">/* x = SERCOM instance number */</span>

<span class="ph token comment">/* I2C slave mode */</span>

SERCOM_I2C_SLAVE_ACK_STATUS <span class="ph token function">SERCOMx_I2C_LastByteAckStatusGet</span><span class="ph token punctuation">(</span><span class="ph token keyword">void</span><span class="ph token punctuation">)</span>	</code></pre></div>
</div>
<div class="topic nested1" aria-labelledby="ariaid-title3" id="summary"><h2 class="title topictitle2" id="ariaid-title3">Summary</h2><div class="body"><p class="p">Returns the ACK status of the last byte written to the I2C master</p>
</div>
</div>
<div class="topic nested1" aria-labelledby="ariaid-title4" id="description"><h2 class="title topictitle2" id="ariaid-title4">Description</h2><div class="body"><p class="p">This function returns the ACK status of the last byte written to the I2C master</p>
</div>
</div>
<div class="topic nested1" aria-labelledby="ariaid-title5" id="precondition"><h2 class="title topictitle2" id="ariaid-title5">Precondition</h2><div class="body"><p class="p">SERCOMx_I2C_Initialize must have been called for the associated SERCOM I2C instance</p>
</div>
</div>
<div class="topic nested1" aria-labelledby="ariaid-title6" id="parameters"><h2 class="title topictitle2" id="ariaid-title6">Parameters</h2><div class="body"><p class="p">None.</p>
</div>
</div>
<div class="topic nested1" aria-labelledby="ariaid-title7" id="returns"><h2 class="title topictitle2" id="ariaid-title7">Returns</h2><div class="body"><p class="p"><em class="ph i">SERCOM_I2C_SLAVE_ACK_STATUS_RECEIVED_ACK</em> - I2C master acknowledged the last byte</p>
<p class="p"><em class="ph i">SERCOM_I2C_SLAVE_ACK_STATUS_RECEIVED_NAK</em> - I2C master sent NAK</p>
</div>
</div>
<div class="topic nested1" aria-labelledby="ariaid-title8" id="example"><h2 class="title topictitle2" id="ariaid-title8">Example</h2><div class="body"><p class="p">The below code snippet shows the use of the SERCOMx_I2C_LastByteAckStatusGet() API
when SERCOM I2C slave PLIB is used in polled mode (interrupt is disabled).</p>
<pre class="pre codeblock language-c"><button title="Copy Code" class="copy-code" onclick="cpy('d569895e72', this);">Copy</button><code id="d569895e72" content="SERCOM_I2C_SLAVE_TRANSFER_DIR transferDir;&#xA;bool isFirstByteSent = false;&#xA;&#xA;SERCOM_I2C_SLAVE_INTFLAG intFlags = SERCOM0_I2C_InterruptFlagsGet();&#xA;&#xA;if (intFlags &amp; SERCOM_I2C_SLAVE_INTFLAG_AMATCH)&#xA;{&#xA;    isFirstByteSent = false;&#xA;    &#xA;    // Read and save the transfer direction in a global variable.&#xA;    transferDir = SERCOM5_I2C_TransferDirGet();&#xA;    &#xA;    // Send ACK succeeded by reception of next byte&#xA;    SERCOM0_I2C_SendCommand(SERCOM_I2C_SLAVE_COMMAND_SEND_ACK);&#xA;}&#xA;else if (intFlags &amp; SERCOM_I2C_SLAVE_INTFLAG_DRDY)&#xA;{&#xA;    if (transferDir == SERCOM_I2C_SLAVE_TRANSFER_DIR_READ)&#xA;    {&#xA;        // I2C master is reading data from I2C slave. Check if the previous data&#xA;        // is acknowledged by the I2C master.&#xA;        &#xA;        if (isFirstByteSent == false)&#xA;        {&#xA;            SERCOM0_I2C_WriteByte(txData);&#xA;            isFirstByteSent = true;&#xA;        }&#xA;        else&#xA;        {&#xA;            if (SERCOM0_I2C_LastByteAckStatusGet() == SERCOM_I2C_SLAVE_ACK_STATUS_RECEIVED_ACK)&#xA;            {&#xA;                // Last byte was acknowledged by the I2C master; send another byte.&#xA;                &#xA;                SERCOM0_I2C_WriteByte(txData);&#xA;                &#xA;                //Execute a byte read operation followed by ACK/NACK reception&#xA;                SERCOM0_I2C_SendCommand(SERCOM_I2C_SLAVE_COMMAND_RECEIVE_ACK_NAK);&#xA;            }&#xA;            else&#xA;            {&#xA;                // Last byte was NAK'd by the I2C master; wait for start condition.&#xA;                &#xA;                //Wait for any start (S/Sr) condition&#xA;                SERCOM0_I2C_SendCommand(SERCOM_I2C_SLAVE_COMMAND_WAIT_FOR_START);&#xA;            }&#xA;        }&#xA;    }&#xA;}&#xA;">SERCOM_I2C_SLAVE_TRANSFER_DIR transferDir<span class="ph token punctuation">;</span>
bool isFirstByteSent <span class="ph token operator">=</span> false<span class="ph token punctuation">;</span>

SERCOM_I2C_SLAVE_INTFLAG intFlags <span class="ph token operator">=</span> <span class="ph token function">SERCOM0_I2C_InterruptFlagsGet</span><span class="ph token punctuation">(</span><span class="ph token punctuation">)</span><span class="ph token punctuation">;</span>

<span class="ph token keyword">if</span> <span class="ph token punctuation">(</span>intFlags <span class="ph token operator">&amp;</span> SERCOM_I2C_SLAVE_INTFLAG_AMATCH<span class="ph token punctuation">)</span>
<span class="ph token punctuation">{</span>
    isFirstByteSent <span class="ph token operator">=</span> false<span class="ph token punctuation">;</span>
    
    <span class="ph token comment">// Read and save the transfer direction in a global variable.</span>
    transferDir <span class="ph token operator">=</span> <span class="ph token function">SERCOM5_I2C_TransferDirGet</span><span class="ph token punctuation">(</span><span class="ph token punctuation">)</span><span class="ph token punctuation">;</span>
    
    <span class="ph token comment">// Send ACK succeeded by reception of next byte</span>
    <span class="ph token function">SERCOM0_I2C_SendCommand</span><span class="ph token punctuation">(</span>SERCOM_I2C_SLAVE_COMMAND_SEND_ACK<span class="ph token punctuation">)</span><span class="ph token punctuation">;</span>
<span class="ph token punctuation">}</span>
<span class="ph token keyword">else</span> <span class="ph token keyword">if</span> <span class="ph token punctuation">(</span>intFlags <span class="ph token operator">&amp;</span> SERCOM_I2C_SLAVE_INTFLAG_DRDY<span class="ph token punctuation">)</span>
<span class="ph token punctuation">{</span>
    <span class="ph token keyword">if</span> <span class="ph token punctuation">(</span>transferDir <span class="ph token operator">==</span> SERCOM_I2C_SLAVE_TRANSFER_DIR_READ<span class="ph token punctuation">)</span>
    <span class="ph token punctuation">{</span>
        <span class="ph token comment">// I2C master is reading data from I2C slave. Check if the previous data</span>
        <span class="ph token comment">// is acknowledged by the I2C master.</span>
        
        <span class="ph token keyword">if</span> <span class="ph token punctuation">(</span>isFirstByteSent <span class="ph token operator">==</span> false<span class="ph token punctuation">)</span>
        <span class="ph token punctuation">{</span>
            <span class="ph token function">SERCOM0_I2C_WriteByte</span><span class="ph token punctuation">(</span>txData<span class="ph token punctuation">)</span><span class="ph token punctuation">;</span>
            isFirstByteSent <span class="ph token operator">=</span> true<span class="ph token punctuation">;</span>
        <span class="ph token punctuation">}</span>
        <span class="ph token keyword">else</span>
        <span class="ph token punctuation">{</span>
            <span class="ph token keyword">if</span> <span class="ph token punctuation">(</span><span class="ph token function">SERCOM0_I2C_LastByteAckStatusGet</span><span class="ph token punctuation">(</span><span class="ph token punctuation">)</span> <span class="ph token operator">==</span> SERCOM_I2C_SLAVE_ACK_STATUS_RECEIVED_ACK<span class="ph token punctuation">)</span>
            <span class="ph token punctuation">{</span>
                <span class="ph token comment">// Last byte was acknowledged by the I2C master; send another byte.</span>
                
                <span class="ph token function">SERCOM0_I2C_WriteByte</span><span class="ph token punctuation">(</span>txData<span class="ph token punctuation">)</span><span class="ph token punctuation">;</span>
                
                <span class="ph token comment">//Execute a byte read operation followed by ACK/NACK reception</span>
                <span class="ph token function">SERCOM0_I2C_SendCommand</span><span class="ph token punctuation">(</span>SERCOM_I2C_SLAVE_COMMAND_RECEIVE_ACK_NAK<span class="ph token punctuation">)</span><span class="ph token punctuation">;</span>
            <span class="ph token punctuation">}</span>
            <span class="ph token keyword">else</span>
            <span class="ph token punctuation">{</span>
                <span class="ph token comment">// Last byte was NAK'd by the I2C master; wait for start condition.</span>
                
                <span class="ph token comment">//Wait for any start (S/Sr) condition</span>
                <span class="ph token function">SERCOM0_I2C_SendCommand</span><span class="ph token punctuation">(</span>SERCOM_I2C_SLAVE_COMMAND_WAIT_FOR_START<span class="ph token punctuation">)</span><span class="ph token punctuation">;</span>
            <span class="ph token punctuation">}</span>
        <span class="ph token punctuation">}</span>
    <span class="ph token punctuation">}</span>
<span class="ph token punctuation">}</span>
</code></pre></div>
</div>
<div class="topic nested1" aria-labelledby="ariaid-title9" id="remarks"><h2 class="title topictitle2" id="ariaid-title9">Remarks</h2><div class="body"><p class="p">Since this API indicates the status of the last byte sent to the I2C master; for sending the first byte to the I2C master, the application must not call this API. Instead, the application should always send the first byte to I2C master's read request. The application would use this API when the SERCOM I2C slave PLIB is used in polled mode (interrupt is disabled).</p>
</div>
</div>
</body>
</html>