<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html
  PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />

<meta http-equiv="X-UA-Compatible" content="IE=EmulateIE11" /><meta name="copyright" content="(C) Copyright 2022" />
<meta name="DC.rights.owner" content="(C) Copyright 2022" />
<meta name="DC.type" content="topic" />
<meta name="DC.title" content="USARTx_Read Function" />
<meta name="DC.format" content="XHTML" />
<meta name="DC.identifier" content="usartx-read-function" />
<link rel="stylesheet" type="text/css" href="stylesheets/commonltr.css" />
<link rel="stylesheet" type="text/css" href="stylesheets/atmel.css" />
<link rel="stylesheet" type="text/css" href="./stylesheets/common-extended.css" /><title>USARTx_Read Function</title>
<meta name="Microsoft.Help.Id" content="GUID-1EA9B250-D935-443A-9FA9-C48E50D229E8-usartx-read-function" />
<meta name="Microsoft.Help.TocParent" content="GUID-1EA9B250-D935-443A-9FA9-C48E50D229E8" />
<meta name="Microsoft.Help.TocOrder" content="0" />
<meta name="Microsoft.Help.Locale" content="en-US" />
<meta name="Microsoft.Help.TopicLocale" content="en-US" />
<meta name="Microsoft.Help.DisplayVersion" content="MPLABÂ® Harmony Peripheral Libraries Reference A 09/2021" />
<script language="javascript">
       
       if (window.parent.location.protocol != 'file:') {
				document.addEventListener('click', function(e) {
				    if (e.target) {
               if (e.target.nodeName == "A" ) {
                    if (!e.target.target) {
                      e.preventDefault();
                      e.stopPropagation();
                              
                      var origUrl = window.parent.location.href.substr(0, window.parent.location.href.indexOf("?"));
                      if (origUrl.length === 0) {
                          origUrl = window.parent.location.href;
                      }
                      var href= e.target.getAttribute("href");
                      var parts = href.split("#");
          
                      var url = "";
                      if (parts.length == 2 ) {
                        if (!parts[0].length) {
                            url = window.parent.location.search.replace('?','')
                        } else {
                            url = parts[0].replace('.html','');
                        }
                      } else {
                        url = parts[0].replace('.html','');
                      }

                      if (parts.length == 2) {
                          url += "#" + parts[1];
                      }
    
                      window.parent.location.href = origUrl + "?" + url;

                      return false;
                    }
               }
            }
				});
			}

		</script><script language="javascript">
        function cpy(id, button) {
        
            var element = document.getElementById(id);
            var content = element.getAttribute("content");
            var textArea = document.createElement("textarea");
            
            // Place in the top-left corner of screen regardless of scroll position.
            textArea.style.position = 'fixed';
            textArea.style.top = 0;
            textArea.style.left = 0;
            
            // Ensure it has a small width and height. Setting to 1px / 1em
            // doesn't work as this gives a negative w/h on some browsers.
            textArea.style.width = '2em';
            textArea.style.height = '2em';
            
            // We don't need padding, reducing the size if it does flash render.
            textArea.style.padding = 0;
            
            // Clean up any borders.
            textArea.style.border = 'none';
            textArea.style.outline = 'none';
            textArea.style.boxShadow = 'none';
            
            // Avoid flash of the white box if rendered for any reason.
            textArea.style.background = 'transparent';
            
            
            textArea.value = content;
            
            document.body.appendChild(textArea);
            textArea.focus();
            textArea.select();
            
            try {
               var successful = document.execCommand('copy');
               var msg = successful ? 'successful' : 'unsuccessful';
               if (!button.classList.contains("copied")){
                  button.textContent = "Copied";
                  button.classList.add("copied");
                  setTimeout(function(){
                    button.textContent = "Copy";
                    button.classList.remove("copied");
                  },1000);
               }
            } catch (err) {
              console.log('Oops, unable to copy');
            }
            
            document.body.removeChild(textArea);
        }
      </script><script language="javascript">
          
          // Add the MathML namespace to html
          var html = document.getElementsByTagName("html")[0],
          head = document.getElementsByTagName("head")[0];
          
          var mathJax = document.createElement("script");
          mathJax.src = "https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-MML-AM_CHTML";
          head.appendChild(mathJax);
          
          html.setAttribute("xmlns:m","http://www.w3.org/1998/Math/MathML");
          
          function inIframe() { try { return window.self !== window.top; } catch (e) { return true; } }
          
          if (!inIframe()) { 
          
          var Default = "index.html?GUID-F43AE0DF-6213-4605-B9DF-820096FFE72B"; 
          
          var displaylocation = "value" + window.location.href;
          
          var GUIDS = displaylocation.split('GUID');          
          
          if (displaylocation.indexOf('#GUID') != -1) {            
          var First = GUIDS[1].split('.html');  
          if (GUIDS[3]){First = GUIDS[2].split('.html');}
          if (GUIDS[4]){First = GUIDS[3].split('.html');}
          if (GUIDS[5]){First = GUIDS[4].split('.html');}
          
          var Second = GUIDS[2].split('#');   
          if (GUIDS[3]){Second = GUIDS[3].split('#');}
          if (GUIDS[4]){Second = GUIDS[4].split('#');}
          if (GUIDS[5]){Second = GUIDS[5].split('#');}
          
          Default = "index.html?" + "GUID" + First[0] + "GUID" + Second[0];     
          }                    
          window.top.location = Default;
          }       
          
        </script><style xml:space="">
        
          button.copy-code{
            display:none;
            padding:0.7em 1.4em;
            margin:0 0.3em 0.3em 0;
            border-radius:0.15em;
            box-sizing: border-box;
            text-decoration:none;
            font-family:'Roboto',sans-serif;
            text-transform:uppercase;
            font-weight:400;
            color:#FFFFFF;
            background-color:#9c9c9c;
            box-shadow:inset 0 -0.6em 0 -0.35em rgba(0,0,0,0.17);
            text-align:center;
            position:relative;
            border: 0;
            float: right;
            border-radius: .5em;
            cursor: pointer;
          }
          button.copy-code:active{
            top:0.1em;
          }
          
          pre:hover button.copy-code{
            display: inline-block !important;
          }
          button.copy-code.copied {
            cursor: default !important;
          }
          
          
          @media all and (max-width:30em){
            button.copy-code{
              display:block;
              margin:0.4em auto;
            }
          }
        
        
      </style></head>
<body id="usartx-read-function">
<h1 class="title topictitle1" id="ariaid-title1">USARTx_Read Function</h1><div class="body"></div>
<div class="topic nested1" aria-labelledby="ariaid-title2" id="c"><h2 class="title topictitle2" id="ariaid-title2">C</h2><div class="body"><pre class="pre codeblock language-c"><button title="Copy Code" class="copy-code" onclick="cpy('d240871e14', this);">Copy</button><code id="d240871e14" content="/* x = USART instance number */&#xA;&#xA;/* Blocking and non-blocking mode */&#xA;&#xA;bool USARTx_Read( void *buffer, const size_t size )&#xA;&#xA;/* Ring buffer mode */&#xA;&#xA;size_t USARTx_Read(uint8_t* buffer, const size_t size)"><span class="ph token comment">/* x = USART instance number */</span>

<span class="ph token comment">/* Blocking and non-blocking mode */</span>

bool <span class="ph token function">USARTx_Read</span><span class="ph token punctuation">(</span> <span class="ph token keyword">void</span> <span class="ph token operator">*</span>buffer<span class="ph token punctuation">,</span> <span class="ph token keyword">const</span> size_t size <span class="ph token punctuation">)</span>

<span class="ph token comment">/* Ring buffer mode */</span>

size_t <span class="ph token function">USARTx_Read</span><span class="ph token punctuation">(</span>uint8_t<span class="ph token operator">*</span> buffer<span class="ph token punctuation">,</span> <span class="ph token keyword">const</span> size_t size<span class="ph token punctuation">)</span></code></pre></div>
</div>
<div class="topic nested1" aria-labelledby="ariaid-title3" id="summary"><h2 class="title topictitle2" id="ariaid-title3">Summary</h2><div class="body"><p class="p"><em class="ph i">Blocking and non-blocking mode</em></p>
<p class="p">Submits a read buffer to the given USART peripheral to process</p>
<p class="p"><em class="ph i">Ring buffer mode</em></p>
<p class="p">Read the requested data from the receive buffer into the application buffer</p>
</div>
</div>
<div class="topic nested1" aria-labelledby="ariaid-title4" id="description"><h2 class="title topictitle2" id="ariaid-title4">Description</h2><div class="body"><p class="p"><em class="ph i">Blocking mode</em></p>
<p class="p">In blocking mode, the API blocks until the requested number of bytes have been received. The return value is true if the requested number of bytes have been read successfully. If not, call the USARTx_ErrorGet API to check the error. The USARTx_ReadCountGet function can be called to know the number of bytes that were received till the error occurred.</p>
<p class="p"><em class="ph i">Non-blocking mode</em></p>
<p class="p">This function submits a read buffer to the USART peripheral to process. A call to this function submits the buffer and the size to the peripheral library and returns immediately. The transfer completion status can either be checked through the callback mechanism or by calling the USARTx_ReadIsBusy function. The success of the operation can be obtained by calling the USARTx_ErrorGet function.  If the USARTx_ErrorGet function returns no error, then this means that the requested number of bytes have been processed. If the function returns some error, the USARTx_ReadCountGet function can be called to know the number of bytes that were received till the error occurred.</p>
<p class="p"><em class="ph i">Ring buffer mode</em></p>
<p class="p">The API copies the number of bytes available in the receive buffer and returns the number of bytes actually copied. If the number of bytes copied is less than the requested size, the application must try reading after some time. If notifications are enabled and a callback is registered, a callback is given when the receive threshold condition is met. This lets the application to get notified when the data is available in the receive buffer.</p>
</div>
</div>
<div class="topic nested1" aria-labelledby="ariaid-title5" id="precondition"><h2 class="title topictitle2" id="ariaid-title5">Precondition</h2><div class="body"><p class="p">USARTx_Initialize must have been called for the associated USART instance.</p>
</div>
</div>
<div class="topic nested1" aria-labelledby="ariaid-title6" id="parameters"><h2 class="title topictitle2" id="ariaid-title6">Parameters</h2><div class="body">
<div class="tablenoborder"><table cellpadding="4" cellspacing="0" summary="" class="table" frame="border" border="1" rules="all"><col style="width:" /><col style="width:" /><thead class="thead" style="text-align:left;"><tr class="row"><th class="entry cellrowborder" style="text-align:left;vertical-align:middle;" id="d240871e111"><span>Param</span></th>
<th class="entry cellrowborder" style="text-align:left;vertical-align:middle;" id="d240871e113"><span>Description</span></th>
</tr>
</thead>
<tbody class="tbody"><tr class="row"><td class="entry cellrowborder" style="text-align:left;vertical-align:middle;" headers="d240871e111 "><span>buffer</span></td>
<td class="entry cellrowborder" style="text-align:left;vertical-align:middle;" headers="d240871e113 "><span>Pointer to the user buffer where received data will be placed.</span></td>
</tr>
<tr class="row"><td class="entry cellrowborder" style="text-align:left;vertical-align:middle;" headers="d240871e111 "><span>size</span></td>
<td class="entry cellrowborder" style="text-align:left;vertical-align:middle;" headers="d240871e113 "><span>Number of bytes to be received. If 9-bit mode is enabled, then the size is specified in terms of number of 9 bit data. For example, if 5 9-bit data are being received, then the size must be specified as 5.</span></td>
</tr>
</tbody>
</table>
</div>
</div>
</div>
<div class="topic nested1" aria-labelledby="ariaid-title7" id="returns"><h2 class="title topictitle2" id="ariaid-title7">Returns</h2><div class="body"><p class="p"><em class="ph i">Blocking and non-blocking mode</em></p>
<p class="p"><em class="ph i">true</em> - if the Read transaction is successful or if the requested size is 0.</p>
<p class="p"><em class="ph i">false</em> - if the arguments are not valid or if the device is busy or if an error occurred while receiving data.</p>
<p class="p"><em class="ph i">Ring buffer mode</em></p>
<p class="p">The API returns the number of bytes actually read into the user buffer. Application must retry by calling this API again if the return value is less than the number of bytes requested. Application can use the USARTx_ReadCountGet API to determine the number of unread bytes available in the receive buffer. Application can also choose to register for event notification to get notified when data is available in the receive buffer (set by the USARTx_ReadThresholdSet API). If 9-bit mode is enabled, then the return value indicates the number of 9-bit data copied to the application buffer.</p>
</div>
</div>
<div class="topic nested1" aria-labelledby="ariaid-title8" id="example"><h2 class="title topictitle2" id="ariaid-title8">Example</h2><div class="body"><p class="p"><em class="ph i">Blocking mode</em></p>
<pre class="pre codeblock language-c"><button title="Copy Code" class="copy-code" onclick="cpy('d240871e153', this);">Copy</button><code id="d240871e153" content="uint8_t rxBuffer[100];&#xA;&#xA;//The below call blocks until the requested bytes have been read&#xA;USART1_Read(rxBuffer, 100);&#xA;    ">uint8_t rxBuffer<span class="ph token punctuation">[</span><span class="ph token number">100</span><span class="ph token punctuation">]</span><span class="ph token punctuation">;</span>

<span class="ph token comment">//The below call blocks until the requested bytes have been read</span>
<span class="ph token function">USART1_Read</span><span class="ph token punctuation">(</span>rxBuffer<span class="ph token punctuation">,</span> <span class="ph token number">100</span><span class="ph token punctuation">)</span><span class="ph token punctuation">;</span>
    </code></pre><p class="p"><em class="ph i">Non-blocking mode</em></p>
<pre class="pre codeblock language-c"><button title="Copy Code" class="copy-code" onclick="cpy('d240871e186', this);">Copy</button><code id="d240871e186" content="uint8_t rxBuffer[100];&#xA;&#xA;//The below call submits the request and returns immediately. Transfer status can be checked either by calling the USARTx_ReadIsBusy API or by registering a callback and getting notified.&#xA;USART1_Read(rxBuffer, 100);&#xA;&#xA;if (USART1_ReadIsBusy() == false)&#xA;{&#xA;&#x9;// Transfer has completed.&#xA;}&#xA;    ">uint8_t rxBuffer<span class="ph token punctuation">[</span><span class="ph token number">100</span><span class="ph token punctuation">]</span><span class="ph token punctuation">;</span>

<span class="ph token comment">//The below call submits the request and returns immediately. Transfer status can be checked either by calling the USARTx_ReadIsBusy API or by registering a callback and getting notified.</span>
<span class="ph token function">USART1_Read</span><span class="ph token punctuation">(</span>rxBuffer<span class="ph token punctuation">,</span> <span class="ph token number">100</span><span class="ph token punctuation">)</span><span class="ph token punctuation">;</span>

<span class="ph token keyword">if</span> <span class="ph token punctuation">(</span><span class="ph token function">USART1_ReadIsBusy</span><span class="ph token punctuation">(</span><span class="ph token punctuation">)</span> <span class="ph token operator">==</span> false<span class="ph token punctuation">)</span>
<span class="ph token punctuation">{</span>
	<span class="ph token comment">// Transfer has completed.</span>
<span class="ph token punctuation">}</span>
    </code></pre><p class="p"><em class="ph i">Ring buffer mode</em></p>
<pre class="pre codeblock language-c"><button title="Copy Code" class="copy-code" onclick="cpy('d240871e247', this);">Copy</button><code id="d240871e247" content="uint8_t rxBuffer[100];&#xA;uint32_t nBytesRead = 0;&#xA;&#xA;nBytesRead = USART1_Read((uint8_t*)rxBuffer, 100);&#xA;if (nBytesRead &lt; 100)&#xA;{&#xA;    // Receive buffer does not have more data, try after some time&#xA;    // Application can even enable notification to get notified when the&#xA;    // data becomes available in the receive buffer&#xA;}&#xA;">uint8_t rxBuffer<span class="ph token punctuation">[</span><span class="ph token number">100</span><span class="ph token punctuation">]</span><span class="ph token punctuation">;</span>
uint32_t nBytesRead <span class="ph token operator">=</span> <span class="ph token number">0</span><span class="ph token punctuation">;</span>

nBytesRead <span class="ph token operator">=</span> <span class="ph token function">USART1_Read</span><span class="ph token punctuation">(</span><span class="ph token punctuation">(</span>uint8_t<span class="ph token operator">*</span><span class="ph token punctuation">)</span>rxBuffer<span class="ph token punctuation">,</span> <span class="ph token number">100</span><span class="ph token punctuation">)</span><span class="ph token punctuation">;</span>
<span class="ph token keyword">if</span> <span class="ph token punctuation">(</span>nBytesRead <span class="ph token operator">&lt;</span> <span class="ph token number">100</span><span class="ph token punctuation">)</span>
<span class="ph token punctuation">{</span>
    <span class="ph token comment">// Receive buffer does not have more data, try after some time</span>
    <span class="ph token comment">// Application can even enable notification to get notified when the</span>
    <span class="ph token comment">// data becomes available in the receive buffer</span>
<span class="ph token punctuation">}</span>
</code></pre></div>
</div>
<div class="topic nested1" aria-labelledby="ariaid-title9" id="remarks"><h2 class="title topictitle2" id="ariaid-title9">Remarks</h2><div class="body"><p class="p">None</p>
</div>
</div>
</body>
</html>