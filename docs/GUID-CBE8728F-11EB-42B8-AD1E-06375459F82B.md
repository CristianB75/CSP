# QSPIx\_MemoryWrite Function

**Parent topic:**[Quad Serial Peripheral Interface \(QSPI\)](GUID-AA725558-EF5D-4D83-9378-06E61B172173.md)

**Parent topic:**[Quad Serial Peripheral Interface \(QSPI\)](GUID-83EB94B5-4BF1-4820-A486-C5B9D1099320.md)

**Parent topic:**[Quad Serial Peripheral Interface \(QSPI\)](GUID-56797157-F046-4DD8-9A9F-CFC59C3A989A.md)

## C

```c
// x - Instance of the QSPI peripheral

bool QSPIx_MemoryWrite
(
qspi_memory_xfer_t *qspi_memory_xfer,
uint32_t *tx_data,
uint32_t tx_data_length,
uint32_t address 
);
```

## Summary

Writes to the specified address of the serial flash device.

## Description

This function can be used to write maximum of one page of data to the specified address of the serial flash device connected as a QSPI slave. If the number of bytes to be written is greater than the page size then QSPIx\_MemoryWrite API needs to be called multiple times.

**Note:** Before sending next write request, QSPIx\_RegisterRead\(\) can be called to read the status register of the slave device to check if the previous write operation is completed.

## Precondition

QSPIx\_Initialize must have been called for the associated QSPI instance. Write enable command has to be sent before write memory request.

## Parameters

|Param|Description|
|-----|-----------|
|\*qspi\_memory\_xfer|pointer to QSPI memory transfer structure holding the instructioncode register and instruction frame register information.|
|\*tx\_data|Pointer to transmit buffer holding the data to write into memory.|
|tx\_data\_length|number of bytes to write.|
|address|Memory location to write to.|

## Returns

-   True on transfer request success.

-   False on transfer request failure.


## Example

```c
#define WRITE_PAGE_CODE 0x02
#define WRITE_IN_PROGRESS (1 << 0)

static qspi_memory_xfer_t qspi_memory_xfer;
static uint8_t buffer[256];
uint32_t address = 0x0;

for (int i = 0; i < 256; i++)
{
    buffer[i] = i;
}

// Write to memory location starting from address 0x0
qspi_memory_xfer.instruction = WRITE_PAGE_CODE;

// Use QAUD SPI Lane
qspi_memory_xfer.width = QUAD_CMD;

if (QSPI0_MemoryWrite(&qspi_memory_xfer, buffer, sizeof(buffer), address) == false)
{
    // Handle Error
}

// Query the status register and wait until WIP bit is cleared.
while(status_reg & WRITE_IN_PROGRESS);

```

