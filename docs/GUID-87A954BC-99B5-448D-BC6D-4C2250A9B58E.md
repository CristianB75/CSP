# Controller Area Network \(CAN\)

The Controller Area Network \(CAN\) module supports the following key<br />features.

Standards Compliance:

-   Full CAN 2.0B compliance

-   Programmable bit rate up to 1 Mbps<br />Message Reception and Transmission:

-   32/16 message FIFOs

-   Each FIFO can have up to 32 messages

-   FIFO can be a transmit message FIFO or a receive message FIFO

-   Userdefined priority levels for message FIFOs used for<br />transmission

-   Acceptance filters for message filtering

-   Acceptance filter mask for message filtering

-   Automatic response to Remote Transmit Request \(RTR\)


**Using The Library**

The CAN library supports the CAN Normal \(Classic\) mode. The CAN Normal<br />mode can transfer message in a polling or an interrupt mode.

**CAN normal operation with polling**

The following example shows the CAN normal mode operation with polling<br />implementation.

```c

void print_menu(void)

{

printf(" ------------------------------ \\r\\n");

printf(" Press '1' to Transmit message \\r\\n");

printf(" Press '2' to Receive message \\r\\n");

}

int main ( void )
{

uint32_t messageID = 0;

uint32_t rx_messageID = 0;

uint8_t message[8];

uint8_t rx_message[8];

uint32_t status = 0;

uint8_t messageLength = 0;

uint8_t rx_messageLength = 0;

uint8_t count = 0;

uint8_t user_input = 0;

CAN_MSG_RX_ATTRIBUTE msgAttr = CAN_MSG_RX_DATA_FRAME;

/* Initialize all modules */

SYS_Initialize ( NULL );

printf(" ------------------------------ \\r\\n");

printf(" CAN Demo \\r\\n");

printf(" ------------------------------ \\r\\n");

print_menu();

/* Prepare the message to send*/

messageID = 0x469;

messageLength = 8;

for (count = 8; count \>=1; count--){

message[count - 1] = count;

}

while ( true )

{

/* Maintain state machines of all polled Harmony modules. */

/* Check if there is a received character */

if(UART6_ReceiverIsReady() == true)

{

if(UART6_ErrorGet() == UART_ERROR_NONE)

{

UART6_Read((void *)&amp;user_input, 1);

}

switch (user_input)

{

case '1':

printf(" Transmitting Message:");

if (CAN1_MessageTransmit(messageID, messageLength, message, 0,
CAN_MSG_TX_DATA_FRAME) == true)

{

printf("Success \\r\\n");

LED_Toggle();

}

else

{

printf("Failed \\r\\n");

}

break;

case '2':

printf(" Waiting for message: \\r\\n");

while (true)

{

if (CAN1_InterruptGet(1, CAN_FIFO_INTERRUPT_RXNEMPTYIF_MASK))

{

/* Check CAN Status */

status = CAN1_ErrorGet();



if (status == CAN_ERROR_NONE)

{

memset(rx_message, 0x00, sizeof(rx_message));



/* Receive New Message */

if (CAN1_MessageReceive(&amp;rx_messageID, &amp;rx_messageLength,
rx_message, 0, 1, &amp;msgAttr) == true)

{

printf(" New Message Received \\r\\n");

status = CAN1_ErrorGet();

if (status == CAN_ERROR_NONE)

{

/* Print message to Console */

uint8_t length = rx_messageLength;

printf(" Message - ID : 0x%x Length : 0x%x ", (unsigned int)
rx_messageID,(unsigned int) rx_messageLength);

printf("Message : ");

while(length)

{

printf("0x%x ", rx_message[rx_messageLength - length--]);

}

printf("\\r\\n");

LED_Toggle();

break;

}

else

{

printf("Error in received message");

}

}

else

{

printf("Message Reception Failed \\r");

}

}

else

{

printf("Error in last received message");

}

}

}

break;

default:

printf(" Invalid Input \\r\\n");

break;

}

print_menu();

}

}



/* Execution should not come here during normal operation */



return ( EXIT_FAILURE );

}
```

**CAN normal operation with interrupt**

The following example shows the CAN normal mode operation with<br />interrupt implementation.

```c

/* Application's state machine enum */

typedef enum

{

APP_STATE_CAN_RECEIVE,

APP_STATE_CAN_TRANSMIT,

APP_STATE_CAN_IDLE,

APP_STATE_CAN_USER_INPUT,

APP_STATE_CAN_XFER_SUCCESSFUL,

APP_STATE_CAN_XFER_ERROR

} APP_STATES;



/* Variable to save application state */

static APP_STATES state = APP_STATE_CAN_USER_INPUT;



void APP_CAN_Callback(uintptr_t context)

{

xferContext = context;



/* Check CAN Status */

status = CAN1_ErrorGet();



if ((status &amp; (CAN_ERROR_TX_RX_WARNING_STATE |
CAN_ERROR_RX_WARNING_STATE |

CAN_ERROR_TX_WARNING_STATE | CAN_ERROR_RX_BUS_PASSIVE_STATE |

CAN_ERROR_TX_BUS_PASSIVE_STATE | CAN_ERROR_TX_BUS_OFF_STATE)) ==
CAN_ERROR_NONE)

{

switch ((APP_STATES)context)

{

case APP_STATE_CAN_RECEIVE:

case APP_STATE_CAN_TRANSMIT:

{

state = APP_STATE_CAN_XFER_SUCCESSFUL;

break;

}

default:

break;

}

}

else

{

state = APP_STATE_CAN_XFER_ERROR;

}

}



int main ( void )
{

uint8_t count = 8;

bool user_input = 0;



/* Initialize all modules */

SYS_Initialize ( NULL );



/* Prepare the message to send*/

messageID = 0x469;

messageLength = 8;

for (count = 8; count \>=1; count--){

message[count - 1] = count;

}



while ( true )

{

if (state == APP_STATE_CAN_USER_INPUT)

{

if(SWITCH_Get() == SWITCH_PRESSED_STATE)

{

while(SWITCH_Get() == SWITCH_PRESSED_STATE);



switch (user_input)

{

case 0:

CAN1_CallbackRegister( APP_CAN_Callback,
(uintptr_t)APP_STATE_CAN_TRANSMIT, 0 );

state = APP_STATE_CAN_IDLE;

CAN1_MessageTransmit(messageID, messageLength, message, 0,
CAN_MSG_TX_DATA_FRAME);

break;

case 1:

CAN1_CallbackRegister( APP_CAN_Callback,
(uintptr_t)APP_STATE_CAN_RECEIVE, 1 );

state = APP_STATE_CAN_IDLE;

memset(rx_message, 0x00, sizeof(rx_message));

/* Receive New Message */

CAN1_MessageReceive(&amp;rx_messageID, &amp;rx_messageLength, rx_message,
0, 1, &amp;msgAttr);

break;

default:

break;

}

}

else

{

continue;

}

}

/* Check the application's current state. */

switch (state)

{

case APP_STATE_CAN_IDLE:

{

/* Application can do other task here */

break;

}

case APP_STATE_CAN_XFER_SUCCESSFUL:

{

if ((APP_STATES)xferContext == APP_STATE_CAN_RECEIVE)

{

}

else if ((APP_STATES)xferContext == APP_STATE_CAN_TRANSMIT)

{

}

LED_Toggle();

state = APP_STATE_CAN_USER_INPUT;

break;

}

case APP_STATE_CAN_XFER_ERROR:

{

if ((APP_STATES)xferContext == APP_STATE_CAN_RECEIVE)

{

}

else

{

}

state = APP_STATE_CAN_USER_INPUT;

break;

}

default:

break;

}



}



/* Execution should not come here during normal operation */



return ( EXIT_FAILURE );
}
```

**Library Interface**

peripheral library provides the following interfaces:

**Functions**

|Name|Description|
|----|-----------|
|CANx\_Initialize|Initializes given instance of the CAN peripheral|
|CANx\_MessageTransmit|Transmits a message into CAN bus|
|CANx\_MessageReceive|Receives a message from CAN bus|
|CANx\_MessageAbort|Abort request for a FIFO|
|CANx\_MessageAcceptanceFilterSet|Set Message acceptance filter configuration|
|CANx\_MessageAcceptanceFilterGet|Get Message acceptance filter configuration|
|CANx\_MessageAcceptanceFilterMaskSet|Set Message acceptance filter mask configuration|
|CANx\_MessageAcceptanceFilterMaskGet|Get Message acceptance filter mask configuration|
|CANx\_ErrorGet|Returns the error during transfer|
|CANx\_ErrorCountGet|Returns the transmit and receive error count during transfer|
|CANx\_InterruptGet|Returns the FIFO Interrupt status|
|CANx\_TxFIFOIsFull|Returns true if Tx FIFO is full otherwise false|
|CANx\_AutoRTRResponseSet|Set the Auto RTR response for remote transmit request|
|CANx\_CallbackRegister|Sets the pointer to the function \(and it's context\) to be called when the given CAN's transfer events occur|
|CANx\_ErrorCallbackRegister|Sets the pointer to the function \(and it's context\) to be called when error occurs in CAN|

**Data types and constants**

|Name|Type|Description|
|----|----|-----------|
|CAN\_MSG\_TX\_ATTRIBUTE|Enum|CAN Message TX Attribute for Data Frame and Remote Frame|
|CAN\_MSG\_RX\_ATTRIBUTE|Enum|CAN Message RX Attribute for Data Frame and Remote Frame|
|CAN\_FIFO\_INTERRUPT\_FLAG\_MASK|Enum|CAN FIFO Interrupt Status Flag Mask|
|CAN\_ERROR|Enum|CAN Transfer Error data type|
|CAN\_CALLBACK|Typedef|CAN Callback Function Pointer|
|CAN\_RX\_MSG|Struct|CAN RX Message Buffer structure|
|CAN\_TX\_RX\_MSG\_BUFFER|Struct|CAN Message Buffer structure|

-   **[CANx\_Initialize Function](GUID-3E146A1F-2790-4E35-9A57-92D94CDA1B7A.md)**  

-   **[CANx\_MessageTransmit Function](GUID-F8FB08F1-1020-4E0E-B699-D668F76EE4CC.md)**  

-   **[CANx\_MessageReceive Function](GUID-AB451CE2-D96C-445A-8F97-8B9565AB2BF7.md)**  

-   **[CANx\_MessageAbort Function](GUID-4E46CDAF-9154-41A4-A3E5-F3534521CF18.md)**  

-   **[CANx\_MessageAcceptanceFilterSet Function](GUID-2CBE4110-28DB-4C92-9465-5C4ACBF3FFC8.md)**  

-   **[CANx\_MessageAcceptanceFilterGet Function](GUID-6E337100-32F5-4051-A12E-D4C576015217.md)**  

-   **[CANx\_MessageAcceptanceFilterMaskSet Function](GUID-7B95D5B8-25D8-4247-8258-8C3FA75213B9.md)**  

-   **[CANx\_MessageAcceptanceFilterMaskGet Function](GUID-A9950957-48E0-4BEE-974D-800D95896821.md)**  

-   **[CANx\_ErrorGet Function](GUID-132D09D6-406E-49B7-893E-81AC3DA848DF.md)**  

-   **[CANx\_ErrorCountGet Function](GUID-C47468D6-2A6E-41E6-B936-72567DF52D2B.md)**  

-   **[CANx\_InterruptGet Function](GUID-403171E7-428F-41E9-99DB-0EAF210A1BB4.md)**  

-   **[CANx\_TxFIFOIsFull Function](GUID-510880B4-8DBA-4ECC-AC8A-DF6B17C14FA2.md)**  

-   **[CANx\_AutoRTRResponseSet Function](GUID-FC5C258E-482B-442B-B10D-5855D6D16986.md)**  

-   **[CANx\_CallbackRegister Function](GUID-46738CBF-1F53-47EC-A81A-378A7C4CA22C.md)**  

-   **[CANx\_ErrorCallbackRegister Function](GUID-8E1F4F48-8DEC-4654-BC98-64CD90BFA9B6.md)**  

-   **[CAN\_MSG\_TX\_ATTRIBUTE Enum](GUID-0D44891B-ADC4-4310-BCED-A371983B0B25.md)**  

-   **[CAN\_MSG\_RX\_ATTRIBUTE Enum](GUID-20996A65-0DB6-4F9C-8F3E-85FAB957A382.md)**  

-   **[CAN\_FIFO\_INTERRUPT\_FLAG\_MASK Enum](GUID-C37E05E5-7D9D-4783-BCA6-54A25967E0AB.md)**  

-   **[CAN\_ERROR Enum](GUID-3D3073B7-75FE-4ED4-8A1D-BE7E1B6EECFF.md)**  

-   **[CAN\_CALLBACK Typedef](GUID-277F12E1-A067-4703-9CAD-AC4BB3EF3236.md)**  

-   **[CAN\_RX\_MSG Struct](GUID-9A522C44-0D81-49DA-BB12-3A35F47C234F.md)**  

-   **[CAN\_TX\_RX\_MSG\_BUFFER Struct](GUID-FE4E9D98-F672-4F2A-A0E4-09BC6270E721.md)**  


**Parent topic:**[PIC32MK GPD GPE MCF Peripheral Libraries](GUID-A63F4C14-72E7-44D7-9C70-A48BBD41B583.md)

**Parent topic:**[PIC32MX 1XX 2XX 5XX Peripheral Libraries](GUID-232A3DC0-B096-45AA-9430-33A2C9BA694A.md)

**Parent topic:**[PIC32MX 5XX 6XX 7XX Peripheral Libraries](GUID-91DC3697-58A9-4E5B-95DE-F4B08BA9C8DD.md)

**Parent topic:**[PIC32MZ DA Peripheral Libraries](GUID-02A4B196-FE06-48DB-BC12-D3A68B6D983E.md)

**Parent topic:**[PIC32MZ EF Peripheral Libraries](GUID-F47955F5-89DE-43B0-8C2C-DE0070EBA152.md)

**Parent topic:**[PIC32MZ W1 Peripheral Libraries](GUID-EBD28D67-7F6E-46D1-9ABE-2BDE1973D143.md)

