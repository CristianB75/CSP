# XDMACn\_ChannelTransfer Function

**Parent topic:**[Extensible DMA Controller \(XDMAC\)](GUID-C2B02311-0F9A-41E7-92B8-C2FEEBDFE755.md)

## C

```c
// n is instance of the peripheral and it is applicable only for devices having multiple instances of the peripheral.
bool XDMACn_ChannelTransfer
(
XDMAC_CHANNEL channel,
const void *srcAddr,
const void *destAddr,
size_t blockSize
)
```

## Summary

Adds a data transfer to a XDMAC channel and enables the channel to start data transfer.

## Description

This function adds a single block data transfer characteristics for a<br />specific XDMAC channel id it is not busy already. It also enables the<br />channel to start data transfer.

If the requesting client registered an event callback with the PLIB,<br />the PLIB will issue a XDMAC\_TRANSFER\_COMPLETE event if the transfer was<br />processed successfully and XDMAC\_TRANSFER\_ERROR event if the transfer was<br />not processed successfully.

## Precondition

XDMAC should have been initialized by calling XDMACn\_Initialize.

## Parameters

|Param|Description|
|-----|-----------|
|channel|A specific XDMAC channel|
|srcAddr|Source of the XDMAC transfer|
|destAddr|Destination of the XDMAC transfer|
|blockSize|Size of the transfer block|

## Returns

*- True* - If transfer request is accepted.

*- False* - If previous transfer is in progress and the request is rejected.

## Example

```c
// Transfer 10 bytes of data to UART TX using XDMAC channel 1
MY_APP_OBJ myAppObj;
uint8_t buf[10] = {0,1,2,3,4,5,6,7,8,9};
    void *srcAddr = (uint8_t *) buf;
    void *destAddr = (uin8_t*) &U1TXREG;
    size_t size = 10;
    
    // User registers an event handler with PLIB. This is done once.
    XDMAC_ChannelCallbackRegister(APP_XDMACTransferEventHandler,
    (uintptr_t)&myAppObj);
    
    if (XDMAC_ChannelTransfer(XDMAC_CHANNEL_1, srcAddr, destAddr, size) == true)
    {
        // do something else
    }
    else
    {
        // try again?
    }
```

## Remarks

When DMA transfer buffers are placed in cacheable memory, cache maintenance operation must be performed by cleaning and invalidating cache for DMA buffers located in cacheable SRAM region using CMSIS APIs. The buffer start address must be aligned to cache line and buffer size must be multiple of cache line. Refer to device documentation to find the cache line size. Invalidate cache lines having received buffer before using it to load the latest data in the actual memory to the cache SCB\_InvalidateDCache\_by\_Addr\(\(uint32\_t \*\)&readBuffer, sizeof\(readBuffer\)\); Clean cache lines having source buffer before submitting a transfer request to XDMAC to load the latest data in the cache to the actual memory SCB\_CleanDCache\_by\_Addr\(\(uint32\_t \*\)&writeBuffer, sizeof\(writeBuffer\)\);

