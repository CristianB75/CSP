# SERCOMx\_I2C\_CommandSet Function

**Parent topic:**[Serial Communication Interface \(SERCOM\)](GUID-76AE7205-E3EF-4EE6-AC28-5153E3565982.md)

## C

```c
/* x = SERCOM instance number */

/* I2C slave mode */

void SERCOMx_I2C_CommandSet(SERCOM_I2C_SLAVE_COMMAND command)	
```

## Summary

Sets I2C slave command

## Description

Sets I2C slave command. The I2C slave state machine takes action based on the set command.

## Precondition

SERCOMx\_I2C\_Initialize must have been called for the associated SERCOM I2C instance

## Parameters

|Param|Description|
|-----|-----------|
|SERCOM\_I2C\_SLAVE\_COMMAND\_SEND\_ACK|Send ACK succeeded by reception of next byte|
|SERCOM\_I2C\_SLAVE\_COMMAND\_SEND\_NAK|Send NAK succeeded by reception of next byte|
|SERCOM\_I2C\_SLAVE\_COMMAND\_RECEIVE\_ACK\_NAK|Execute a byte read operation followed by ACK/NACK reception|
|SERCOM\_I2C\_SLAVE\_COMMAND\_WAIT\_FOR\_START|Wait for any start \(S/Sr\) condition|

## Returns

None.

## Example

The below code snippet shows how SERCOMx\_I2C\_CommandSet\(\) API can be used<br />when SERCOM I2C slave PLIB is used in polled mode \(interrupt is disabled\).

```c
static bool isFirstByteSent;
static bool transferDir;
// Define a flag that inidicates if the I2C slave application is busy or ready
static bool isAppBusy;
SERCOM_I2C_SLAVE_INTFLAG intFlags = SERCOM5_I2C_InterruptFlagsGet();

if (intFlags & SERCOM_I2C_SLAVE_INTFLAG_AMATCH)
{
    isFirstByteSent = false;
    
    // Read and save the transfer direction in a global variable.
    transferDir = SERCOM5_I2C_TransferDirGet();
    
    if (isAppBusy == true)
    {
        // I2C slave application is busy. Send NAK.
        SERCOM0_I2C_SendCommand(SERCOM_I2C_SLAVE_COMMAND_SEND_NAK);
    }
    else
    {
        // I2C slave application is ready. Send ACK succeeded by reception of next byte
        SERCOM0_I2C_SendCommand(SERCOM_I2C_SLAVE_COMMAND_SEND_ACK);
    }
}
else if (intFlags & SERCOM_I2C_SLAVE_INTFLAG_DRDY)
{
    if (transferDir == SERCOM_I2C_SLAVE_TRANSFER_DIR_WRITE)
    {
        // I2C master is writing data to I2C slave. Read the received byte.
        rxByte = SERCOM0_I2C_ReadByte();
        
        // Execute acknowledge action succeeded by reception of next byte
        SERCOM0_I2C_SendCommand(SERCOM_I2C_SLAVE_COMMAND_SEND_ACK);
    }
    else
    {
        // I2C master is reading data from I2C slave. Check if the previous data
        // is acknowledged by the I2C master.
        
        if (isFirstByteSent == false)
        {
            SERCOM0_I2C_WriteByte(txData);
            isFirstByteSent = true;
        }
        else
        {
            if (SERCOM0_I2C_LastByteAckStatusGet() == SERCOM_I2C_SLAVE_ACK_STATUS_RECEIVED_ACK)
            {
                // Last byte was acknowledged by the I2C master; send another byte.
                
                SERCOM0_I2C_WriteByte(txData);
                
                //Execute a byte read operation followed by ACK/NACK reception
                SERCOM0_I2C_SendCommand(SERCOM_I2C_SLAVE_COMMAND_RECEIVE_ACK_NAK);
            }
            else
            {
                // Last byte was NAK'd by the I2C master; wait for start condition.
                
                //Wait for any start (S/Sr) condition
                SERCOM0_I2C_SendCommand(SERCOM_I2C_SLAVE_COMMAND_WAIT_FOR_START);
            }
        }
    }
}
else if (intFlags & SERCOM_I2C_SLAVE_INTFLAG_PREC)
{
    SERCOM0_I2C_InterruptFlagsClear(SERCOM_I2C_SLAVE_INTFLAG_PREC);
}
```

## Remarks

This API is generated when Smart mode is disabled and is typically used when the SERCOM I2C slave PLIB is used in polled mode \(interrupt is disabled\).

