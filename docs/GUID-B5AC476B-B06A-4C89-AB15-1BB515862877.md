# Control Area Network \(CAN\)

The Controller Area Network \(CAN\) performs communication according to<br />ISO 11898-1:2015 and to Bosch CAN-FD specification. Additional<br />transceiver hardware is required for connection to the physical layer.

All functions concerning the handling of messages are implemented by<br />the Rx Handler and the Tx Handler. The Rx Handler manages message<br />acceptance filtering, the transfer of received messages from the CAN<br />core to the Message RAM, as well as providing receive message status<br />information. The Tx Handler is responsible for the transfer of transmit<br />messages from the Message RAM to the CAN core, as well as providing<br />transmit status information. Acceptance filtering is implemented by a<br />combination of up to 128 filter elements, where each element can be<br />configured as a range, as a bit mask, or as a dedicated ID filter.

**Using The Library**

The CAN library supports the Normal and CAN-FD modes. The CAN Normal or<br />CAN-FD mode can transfer message in a polling or an interrupt mode.

**CAN Message RAM Configuration**

Allocate CAN Message RAM Configuration in contiguous non-cacheable<br />buffer as uint8\_t Can1MessageRAM<br />**attribute**\(\(aligned \(32\)\)\), here additional attribute such as<br />**attribute**\(\(**section**\(".region\_nocache"\)\)\) or<br />**attribute**\(\(space\(data\), section \(".ram\_nocache"\)\)\) should be added<br />if cache is enabled and non-cacheable section should be created in<br />linker script.

**CAN polling mode:**

```c
#include <stddef.h>                     // Defines NULL
#include <stdbool.h>                    // Defines true
#include <stdlib.h>                     // Defines EXIT_FAILURE
#include "definitions.h"                // SYS function prototypes

uint8_t Can1MessageRAM[CAN1_MESSAGE_RAM_CONFIG_SIZE] __attribute__((aligned (32)));

/* Standard identifier id[28:18]*/
#define WRITE_ID(id) (id << 18)
#define READ_ID(id)  (id >> 18)

static uint32_t status = 0;
static uint8_t loop_count = 0;
static uint8_t user_input = 0;

static uint8_t txFiFo[CAN1_TX_FIFO_BUFFER_SIZE];
static uint8_t rxFiFo0[CAN1_RX_FIFO0_SIZE];
static uint8_t rxFiFo1[CAN1_RX_FIFO1_SIZE];
static uint8_t rxBuffer[CAN1_RX_BUFFER_SIZE];

// *****************************************************************************
// *****************************************************************************
// Section: Local functions
// *****************************************************************************
// *****************************************************************************

/* Message Length to Data length code */
static uint8_t CANLengthToDlcGet(uint8_t length)
{
    uint8_t dlc = 0;

    if (length <= 8U)
    {
        dlc = length;
    }
    else if (length <= 12U)
    {
        dlc = 0x9U;
    }
    else if (length <= 16U)
    {
        dlc = 0xAU;
    }
    else if (length <= 20U)
    {
        dlc = 0xBU;
    }
    else if (length <= 24U)
    {
        dlc = 0xCU;
    }
    else if (length <= 32U)
    {
        dlc = 0xDU;
    }
    else if (length <= 48U)
    {
        dlc = 0xEU;
    }
    else
    {
        dlc = 0xFU;
    }
    return dlc;
}

/* Data length code to Message Length */
static uint8_t CANDlcToLengthGet(uint8_t dlc)
{
    uint8_t msgLength[] = {0U, 1U, 2U, 3U, 4U, 5U, 6U, 7U, 8U, 12U, 16U, 20U, 24U, 32U, 48U, 64U};
    return msgLength[dlc];
}

/* Menu */
static void display_menu(void)
{
	printf("Menu :\r\n"
	       "  -- Select the action:\r\n"
	       "  0: Send FD standard message with ID: 0x45A and 64 byte data 0 to 63. \r\n"
	       "  1: Send FD standard message with ID: 0x469 and 64 byte data 128 to 191. \r\n"
	       "  2: Send FD extended message with ID: 0x100000A5 and 64 byte data 0 to 63. \r\n"
	       "  3: Send FD extended message with ID: 0x10000096 and 64 byte data 128 to 191. \r\n"
	       "  4: Send normal standard message with ID: 0x469 and 8 byte data 0 to 7. \r\n"
	       "  m: Display menu \r\n\r\n");
}

/* Print Rx Message */
static void print_message(uint8_t numberOfMessage, CAN_RX_BUFFER *rxBuf, uint8_t rxBufLen, uint8_t rxFifoBuf)
{
    uint8_t length = 0;
    uint8_t msgLength = 0;
    uint32_t id = 0;

    if (rxFifoBuf == 0)
        printf(" Rx FIFO0 :");
    else if (rxFifoBuf == 1)
        printf(" Rx FIFO1 :");
    else if (rxFifoBuf == 2)
        printf(" Rx Buffer :");

    for (uint8_t count = 0; count < numberOfMessage; count++)
    {
        /* Print message to Console */
        printf(" New Message Received\r\n");
        id = rxBuf->xtd ? rxBuf->id : READ_ID(rxBuf->id);
        msgLength = CANDlcToLengthGet(rxBuf->dlc);
        length = msgLength;
        printf(" Message - ID : 0x%x Length : 0x%x ", (unsigned int)id, (unsigned int)msgLength);
        printf("Message : ");
        while(length)
        {
            printf("0x%x ", rxBuf->data[msgLength - length--]);
        }
        printf("\r\n");
        rxBuf += rxBufLen;
    }
}

// *****************************************************************************
// *****************************************************************************
// Section: Main Entry Point
// *****************************************************************************
// *****************************************************************************

int main ( void )
{
    CAN_TX_BUFFER *txBuffer = NULL;
    uint8_t        bufferNumber = 0;
    uint8_t        numberOfMessage = 0;

    /* Initialize all modules */
    SYS_Initialize ( NULL );

    printf(" ------------------------------ \r\n");
    printf("            CAN FD Demo          \r\n");
    printf(" ------------------------------ \r\n");
    
    /* Set Message RAM Configuration */
    CAN1_MessageRAMConfigSet(Can1MessageRAM);

    display_menu();
     
    while ( true )
    {
        /* Rx Buffers */
        if (CAN1_InterruptGet(CAN_INTERRUPT_DRX_MASK))
        {    
            CAN1_InterruptClear(CAN_INTERRUPT_DRX_MASK);

            /* Check CAN Status */
            status = CAN1_ErrorGet();

            if (((status & CAN_PSR_LEC_Msk) == CAN_ERROR_NONE) || ((status & CAN_PSR_LEC_Msk) == CAN_ERROR_LEC_NC))
            {
                if (CAN1_RxBufferNumberGet(&bufferNumber))
                {
                    memset(rxBuffer, 0x00, CAN1_RX_BUFFER_ELEMENT_SIZE);
                    if (CAN1_MessageReceive(bufferNumber, (CAN_RX_BUFFER *)rxBuffer) == true)
                    {
                        print_message(1, (CAN_RX_BUFFER *)rxBuffer, CAN1_RX_BUFFER_ELEMENT_SIZE, 2);
                    }
                    else
                    {
                        printf(" Error in received message\r\n");
                    }
                }
            }
            else
            {
                printf(" Error in received message\r\n");
            }
        }

        /* Rx FIFO0 */
        if (CAN1_InterruptGet(CAN_INTERRUPT_RF0N_MASK))
        {    
            CAN1_InterruptClear(CAN_INTERRUPT_RF0N_MASK);

            /* Check CAN Status */
            status = CAN1_ErrorGet();

            if (((status & CAN_PSR_LEC_Msk) == CAN_ERROR_NONE) || ((status & CAN_PSR_LEC_Msk) == CAN_ERROR_LEC_NC))
            {
                numberOfMessage = CAN1_RxFifoFillLevelGet(CAN_RX_FIFO_0);
                if (numberOfMessage != 0)
                {
                    memset(rxFiFo0, 0x00, (numberOfMessage * CAN1_RX_FIFO0_ELEMENT_SIZE));
                    if (CAN1_MessageReceiveFifo(CAN_RX_FIFO_0, numberOfMessage, (CAN_RX_BUFFER *)rxFiFo0) == true)
                    {
                        print_message(numberOfMessage, (CAN_RX_BUFFER *)rxFiFo0, CAN1_RX_FIFO0_ELEMENT_SIZE, 0);
                    }
                    else
                    {
                        printf(" Error in received message\r\n");
                    }
                }
            }
            else
            {
                printf(" Error in received message\r\n");
            }
        }

        /* Rx FIFO1 */
        if (CAN1_InterruptGet(CAN_INTERRUPT_RF1N_MASK))
        {    
            CAN1_InterruptClear(CAN_INTERRUPT_RF1N_MASK);

            /* Check CAN Status */
            status = CAN1_ErrorGet();

            if (((status & CAN_PSR_LEC_Msk) == CAN_ERROR_NONE) || ((status & CAN_PSR_LEC_Msk) == CAN_ERROR_LEC_NC))
            {
                numberOfMessage = CAN1_RxFifoFillLevelGet(CAN_RX_FIFO_1);
                if (numberOfMessage != 0)
                {
                    memset(rxFiFo1, 0x00, (numberOfMessage * CAN1_RX_FIFO1_ELEMENT_SIZE));
                    if (CAN1_MessageReceiveFifo(CAN_RX_FIFO_1, numberOfMessage, (CAN_RX_BUFFER *)rxFiFo1) == true)
                    {
                        print_message(numberOfMessage, (CAN_RX_BUFFER *)rxFiFo1, CAN1_RX_FIFO1_ELEMENT_SIZE, 1);
                    }
                    else
                    {
                        printf(" Error in received message\r\n");
                    }
                }
            }
            else
            {
                printf(" Error in received message\r\n");
            }
        }

        /* User input */
        if (SERCOM4_USART_ReceiverIsReady() == false)
        {
            continue;
        }
        user_input = (uint8_t)SERCOM4_USART_ReadByte();

        switch (user_input)
        {
            case '0':
                memset(txFiFo, 0x00, CAN1_TX_FIFO_BUFFER_ELEMENT_SIZE);
                txBuffer = (CAN_TX_BUFFER *)txFiFo;
                txBuffer->id = WRITE_ID(0x45A);
                txBuffer->dlc = CANLengthToDlcGet(64);
                txBuffer->fdf = 1;
                txBuffer->brs = 1;
                for (loop_count = 0; loop_count < 64; loop_count++){
                    txBuffer->data[loop_count] = loop_count;
                }                
                printf("  0: Send FD standard message with ID: 0x45A and 64 byte data 0 to 63.\r\n");
                if (CAN1_MessageTransmitFifo(1, txBuffer) == true)
                {    
                    printf(" Success \r\n");
                }
                else
                {
                    printf(" Failed \r\n");
                }             
                break;  
            case '1':
                memset(txFiFo, 0x00, CAN1_TX_FIFO_BUFFER_ELEMENT_SIZE);
                txBuffer = (CAN_TX_BUFFER *)txFiFo;
                txBuffer->id = WRITE_ID(0x469);
                txBuffer->dlc = CANLengthToDlcGet(64);
                txBuffer->fdf = 1;
                txBuffer->brs = 1;
                for (loop_count = 128; loop_count < 192; loop_count++){
                    txBuffer->data[loop_count - 128] = loop_count;
                }                
                printf("  1: Send FD standard message with ID: 0x469 and 64 byte data 128 to 191.\r\n");
                if (CAN1_MessageTransmitFifo(1, txBuffer) == true)
                {    
                    printf(" Success \r\n");
                }
                else
                {
                    printf(" Failed \r\n");
                }    
                break;
            case '2': 
                memset(txFiFo, 0x00, CAN1_TX_FIFO_BUFFER_ELEMENT_SIZE);
                txBuffer = (CAN_TX_BUFFER *)txFiFo;
                txBuffer->id = 0x100000A5;
                txBuffer->dlc = CANLengthToDlcGet(64);
                txBuffer->xtd = 1;
                txBuffer->fdf = 1;
                txBuffer->brs = 1;
                for (loop_count = 0; loop_count < 64; loop_count++){
                    txBuffer->data[loop_count] = loop_count;
                }
                printf("  2: Send FD extended message with ID: 0x100000A5 and 64 byte data 0 to 63.\r\n");
                if (CAN1_MessageTransmitFifo(1, txBuffer) == true)
                {    
                    printf(" Success \r\n");
                }
                else
                {
                    printf(" Failed \r\n");
                }             
                break;
            case '3':
                memset(txFiFo, 0x00, CAN1_TX_FIFO_BUFFER_ELEMENT_SIZE);
                txBuffer = (CAN_TX_BUFFER *)txFiFo;
                txBuffer->id = 0x10000096;
                txBuffer->dlc = CANLengthToDlcGet(64);
                txBuffer->xtd = 1;
                txBuffer->fdf = 1;
                txBuffer->brs = 1;
                for (loop_count = 128; loop_count < 192; loop_count++){
                    txBuffer->data[loop_count - 128] = loop_count;
                }
                printf("  3: Send FD extended message with ID: 0x10000096 and 64 byte data 128 to 191.\r\n");
                if (CAN1_MessageTransmitFifo(1, txBuffer) == true)
                {    
                    printf(" Success \r\n");
                }
                else
                {
                    printf(" Failed \r\n");
                }             
                break;
            
            case '4':
                memset(txFiFo, 0x00, CAN1_TX_FIFO_BUFFER_ELEMENT_SIZE);
                txBuffer = (CAN_TX_BUFFER *)txFiFo;
                txBuffer->id = WRITE_ID(0x469);
                txBuffer->dlc = 8;
                for (loop_count = 0; loop_count < 8; loop_count++){
                    txBuffer->data[loop_count] = loop_count;
                }                
                printf("  4: Send normal standard message with ID: 0x469 and 8 byte data 0 to 7.\r\n");
                if (CAN1_MessageTransmitFifo(1, txBuffer) == true)
                {    
                    printf(" Success \r\n");
                }
                else
                {
                    printf(" Failed \r\n");
                }             
                break;                 

            case 'm':
            case 'M':
                display_menu();
                break;
                
            default:
                printf(" Invalid Input \r\n");
                break;
        }  
    }

    /* Execution should not come here during normal operation */

    return ( EXIT_FAILURE );
}

```

**CAN interrupt mode:**

```c
#include <stddef.h>                     // Defines NULL
#include <stdbool.h>                    // Defines true
#include <stdlib.h>                     // Defines EXIT_FAILURE
#include "definitions.h"                // SYS function prototypes

uint8_t Can1MessageRAM[CAN1_MESSAGE_RAM_CONFIG_SIZE] __attribute__((aligned (32)));

/* Standard identifier id[28:18]*/
#define WRITE_ID(id) (id << 18)
#define READ_ID(id)  (id >> 18)

/* Application's state machine enum */
typedef enum
{
    APP_STATE_CAN_RECEIVE,
    APP_STATE_CAN_TRANSMIT,
    APP_STATE_CAN_IDLE,
    APP_STATE_CAN_XFER_SUCCESSFUL,
    APP_STATE_CAN_XFER_ERROR,
    APP_STATE_CAN_USER_INPUT
} APP_STATES;

/* Variable to save Tx/Rx transfer status and context */
static uint32_t status = 0;
static uint32_t xferContext = 0;
/* Variable to save Tx/Rx message */
static uint8_t loop_count = 0;
static uint8_t user_input = 0;
/* Variable to save application state */
volatile static APP_STATES state = APP_STATE_CAN_USER_INPUT;

static uint8_t txFiFo[CAN1_TX_FIFO_BUFFER_SIZE];
static uint8_t rxFiFo0[CAN1_RX_FIFO0_SIZE];
static uint8_t rxFiFo1[CAN1_RX_FIFO1_SIZE];
static uint8_t rxBuffer[CAN1_RX_BUFFER_SIZE];

// *****************************************************************************
// *****************************************************************************
// Section: Local functions
// *****************************************************************************
// *****************************************************************************

/* Message Length to Data length code */
static uint8_t CANLengthToDlcGet(uint8_t length)
{
    uint8_t dlc = 0;

    if (length <= 8U)
    {
        dlc = length;
    }
    else if (length <= 12U)
    {
        dlc = 0x9U;
    }
    else if (length <= 16U)
    {
        dlc = 0xAU;
    }
    else if (length <= 20U)
    {
        dlc = 0xBU;
    }
    else if (length <= 24U)
    {
        dlc = 0xCU;
    }
    else if (length <= 32U)
    {
        dlc = 0xDU;
    }
    else if (length <= 48U)
    {
        dlc = 0xEU;
    }
    else
    {
        dlc = 0xFU;
    }
    return dlc;
}

/* Data length code to Message Length */
static uint8_t CANDlcToLengthGet(uint8_t dlc)
{
    uint8_t msgLength[] = {0U, 1U, 2U, 3U, 4U, 5U, 6U, 7U, 8U, 12U, 16U, 20U, 24U, 32U, 48U, 64U};
    return msgLength[dlc];
}

/* Menu */
static void display_menu(void)
{
	printf("Menu :\r\n"
	       "  -- Select the action:\r\n"
	       "  0: Send FD standard message with ID: 0x45A and 64 byte data 0 to 63. \r\n"
	       "  1: Send FD standard message with ID: 0x469 and 64 byte data 128 to 191. \r\n"
	       "  2: Send FD extended message with ID: 0x100000A5 and 64 byte data 0 to 63. \r\n"
	       "  3: Send FD extended message with ID: 0x10000096 and 64 byte data 128 to 191. \r\n"
	       "  4: Send normal standard message with ID: 0x469 and 8 byte data 0 to 7. \r\n"
	       "  m: Display menu \r\n\r\n");
}

/* Print Rx Message */
static void print_message(uint8_t numberOfMessage, CAN_RX_BUFFER *rxBuf, uint8_t rxBufLen, uint8_t rxFifoBuf)
{
    uint8_t length = 0;
    uint8_t msgLength = 0;
    uint32_t id = 0;

    if (rxFifoBuf == 0)
        printf(" Rx FIFO0 :");
    else if (rxFifoBuf == 1)
        printf(" Rx FIFO1 :");
    else if (rxFifoBuf == 2)
        printf(" Rx Buffer :");

    for (uint8_t count = 0; count < numberOfMessage; count++)
    {
        /* Print message to Console */
        printf(" New Message Received\r\n");
        id = rxBuf->xtd ? rxBuf->id : READ_ID(rxBuf->id);
        msgLength = CANDlcToLengthGet(rxBuf->dlc);
        length = msgLength;
        printf(" Message - Timestamp : 0x%x ID : 0x%x Length : 0x%x ", (unsigned int)rxBuf->rxts, (unsigned int)id, (unsigned int)msgLength);
        printf("Message : ");
        while(length)
        {
            printf("0x%x ", rxBuf->data[msgLength - length--]);
        }
        printf("\r\n");
        rxBuf += rxBufLen;
    }
}

/* This function will be called by CAN PLIB when transfer is completed from Tx FIFO */
void APP_CAN_TxFifoCallback(uintptr_t context)
{
    xferContext = context;

    /* Check CAN Status */
    status = CAN1_ErrorGet();

    if (((status & CAN_PSR_LEC_Msk) == CAN_ERROR_NONE) || ((status & CAN_PSR_LEC_Msk) == CAN_ERROR_LEC_NC))
    {
        switch ((APP_STATES)context)
        {
            case APP_STATE_CAN_TRANSMIT:
            {
                state = APP_STATE_CAN_XFER_SUCCESSFUL;
                break;
            }
            default:
                break;
        }
    }
    else
    {
        state = APP_STATE_CAN_XFER_ERROR;
    }
}

/* This function will be called by CAN PLIB when Message received in Rx Buffer */
void APP_CAN_RxBufferCallback(uint8_t bufferNumber, uintptr_t context)
{
    xferContext = context;

    /* Check CAN Status */
    status = CAN1_ErrorGet();

    if (((status & CAN_PSR_LEC_Msk) == CAN_ERROR_NONE) || ((status & CAN_PSR_LEC_Msk) == CAN_ERROR_LEC_NC))
    {
        switch ((APP_STATES)context)
        {
            case APP_STATE_CAN_RECEIVE:
            {
                memset(rxBuffer, 0x00, CAN1_RX_BUFFER_ELEMENT_SIZE);
                if (CAN1_MessageReceive(bufferNumber, (CAN_RX_BUFFER *)rxBuffer) == true)
                {
                    print_message(1, (CAN_RX_BUFFER *)rxBuffer, CAN1_RX_BUFFER_ELEMENT_SIZE, 2);
                    state = APP_STATE_CAN_XFER_SUCCESSFUL;
                }
                else
                {
                    state = APP_STATE_CAN_XFER_ERROR;
                }
                break;
            }
            default:
                break;
        }
    }
    else
    {
        state = APP_STATE_CAN_XFER_ERROR;
    }
}

/* This function will be called by CAN PLIB when Message received in Rx FIFO0 */
void APP_CAN_RxFifo0Callback(uint8_t numberOfMessage, uintptr_t context)
{
    xferContext = context;

    /* Check CAN Status */
    status = CAN1_ErrorGet();

    if (((status & CAN_PSR_LEC_Msk) == CAN_ERROR_NONE) || ((status & CAN_PSR_LEC_Msk) == CAN_ERROR_LEC_NC))
    {
        switch ((APP_STATES)context)
        {
            case APP_STATE_CAN_RECEIVE:
            {
                memset(rxFiFo0, 0x00, (numberOfMessage * CAN1_RX_FIFO0_ELEMENT_SIZE));
                if (CAN1_MessageReceiveFifo(CAN_RX_FIFO_0, numberOfMessage, (CAN_RX_BUFFER *)rxFiFo0) == true)
                {
                    print_message(numberOfMessage, (CAN_RX_BUFFER *)rxFiFo0, CAN1_RX_FIFO0_ELEMENT_SIZE, 0);
                    state = APP_STATE_CAN_XFER_SUCCESSFUL;
                }
                else
                {
                    state = APP_STATE_CAN_XFER_ERROR;
                }
                break;
            }
            default:
                break;
        }
    }
    else
    {
        state = APP_STATE_CAN_XFER_ERROR;
    }
}

/* This function will be called by CAN PLIB when Message received in Rx FIFO1 */
void APP_CAN_RxFifo1Callback(uint8_t numberOfMessage, uintptr_t context)
{
    xferContext = context;

    /* Check CAN Status */
    status = CAN1_ErrorGet();

    if (((status & CAN_PSR_LEC_Msk) == CAN_ERROR_NONE) || ((status & CAN_PSR_LEC_Msk) == CAN_ERROR_LEC_NC))
    {
        switch ((APP_STATES)context)
        {
            case APP_STATE_CAN_RECEIVE:
            {
                memset(rxFiFo1, 0x00, (numberOfMessage * CAN1_RX_FIFO1_ELEMENT_SIZE));
                if (CAN1_MessageReceiveFifo(CAN_RX_FIFO_1, numberOfMessage, (CAN_RX_BUFFER *)rxFiFo1) == true)
                {
                    print_message(numberOfMessage, (CAN_RX_BUFFER *)rxFiFo1, CAN1_RX_FIFO1_ELEMENT_SIZE, 1);
                    state = APP_STATE_CAN_XFER_SUCCESSFUL;
                }
                else
                {
                    state = APP_STATE_CAN_XFER_ERROR;
                }
                break;
            }
            default:
                break;
        }
    }
    else
    {
        state = APP_STATE_CAN_XFER_ERROR;
    }
}

// *****************************************************************************
// *****************************************************************************
// Section: Main Entry Point
// *****************************************************************************
// *****************************************************************************

int main ( void )
{
    CAN_TX_BUFFER *txBuffer = NULL;

    /* Initialize all modules */
    SYS_Initialize ( NULL );

    printf(" ------------------------------ \r\n");
    printf("        CAN FD Demo            \r\n");
    printf(" ------------------------------ \r\n");
    
    /* Set Message RAM Configuration */
    CAN1_MessageRAMConfigSet(Can1MessageRAM);

    CAN1_RxFifoCallbackRegister(CAN_RX_FIFO_0, APP_CAN_RxFifo0Callback, APP_STATE_CAN_RECEIVE);
    CAN1_RxFifoCallbackRegister(CAN_RX_FIFO_1, APP_CAN_RxFifo1Callback, APP_STATE_CAN_RECEIVE);
    CAN1_RxBuffersCallbackRegister(APP_CAN_RxBufferCallback, APP_STATE_CAN_RECEIVE);

    display_menu();
    
    while ( true )
    {
        if (state == APP_STATE_CAN_USER_INPUT)
        {
            /* Read user input */
            scanf("%c", (char *) &user_input);
            
            switch (user_input)
            {
				case '0':
                    memset(txFiFo, 0x00, CAN1_TX_FIFO_BUFFER_ELEMENT_SIZE);
                    txBuffer = (CAN_TX_BUFFER *)txFiFo;
                    txBuffer->id = WRITE_ID(0x45A);
                    txBuffer->dlc = CANLengthToDlcGet(64);
                    txBuffer->fdf = 1;
                    txBuffer->brs = 1;
					for (loop_count = 0; loop_count < 64; loop_count++){
						txBuffer->data[loop_count] = loop_count;
					}                
					printf("  0: Send FD standard message with ID: 0x45A and 64 byte data 0 to 63.\r\n");
                    CAN1_TxFifoCallbackRegister( APP_CAN_TxFifoCallback, (uintptr_t)APP_STATE_CAN_TRANSMIT );
                    state = APP_STATE_CAN_IDLE;
                    if (CAN1_MessageTransmitFifo(1, txBuffer) == false)
                    {
                        printf(" Failed \r\n");
                    }             
                    break;
				case '1':
                    memset(txFiFo, 0x00, CAN1_TX_FIFO_BUFFER_ELEMENT_SIZE);
                    txBuffer = (CAN_TX_BUFFER *)txFiFo;
                    txBuffer->id = WRITE_ID(0x469);
                    txBuffer->dlc = CANLengthToDlcGet(64);
                    txBuffer->fdf = 1;
                    txBuffer->brs = 1;
					for (loop_count = 128; loop_count < 192; loop_count++){
						txBuffer->data[loop_count - 128] = loop_count;
					}                
 					printf("  1: Send FD standard message with ID: 0x469 and 64 byte data 128 to 191.\r\n");
					CAN1_TxFifoCallbackRegister( APP_CAN_TxFifoCallback, (uintptr_t)APP_STATE_CAN_TRANSMIT );
                    state = APP_STATE_CAN_IDLE;
					if (CAN1_MessageTransmitFifo(1, txBuffer) == false)
                    {
                        printf(" Failed \r\n");
                    }             
                    break;
				case '2':
                    memset(txFiFo, 0x00, CAN1_TX_FIFO_BUFFER_ELEMENT_SIZE);
                    txBuffer = (CAN_TX_BUFFER *)txFiFo;
                    txBuffer->id = 0x100000A5;
                    txBuffer->dlc = CANLengthToDlcGet(64);
                    txBuffer->xtd = 1;
                    txBuffer->fdf = 1;
                    txBuffer->brs = 1;
					for (loop_count = 0; loop_count < 64; loop_count++){
						txBuffer->data[loop_count] = loop_count;
					}
					printf("  2: Send FD extended message with ID: 0x100000A5 and 64 byte data 0 to 63.\r\n");
                    CAN1_TxFifoCallbackRegister( APP_CAN_TxFifoCallback, (uintptr_t)APP_STATE_CAN_TRANSMIT );
                    state = APP_STATE_CAN_IDLE;
                    if (CAN1_MessageTransmitFifo(1, txBuffer) == false)
                    {
                        printf(" Failed \r\n");
                    }
                    break;
				case '3':
                    memset(txFiFo, 0x00, CAN1_TX_FIFO_BUFFER_ELEMENT_SIZE);
                    txBuffer = (CAN_TX_BUFFER *)txFiFo;
                    txBuffer->id = 0x10000096;
                    txBuffer->dlc = CANLengthToDlcGet(64);
                    txBuffer->xtd = 1;
                    txBuffer->fdf = 1;
                    txBuffer->brs = 1;
					for (loop_count = 128; loop_count < 192; loop_count++){
						txBuffer->data[loop_count - 128] = loop_count;
					}
					printf("  3: Send FD extended message with ID: 0x10000096 and 64 byte data 128 to 191.\r\n");
                    CAN1_TxFifoCallbackRegister( APP_CAN_TxFifoCallback, (uintptr_t)APP_STATE_CAN_TRANSMIT );
                    state = APP_STATE_CAN_IDLE;
                    if (CAN1_MessageTransmitFifo(1, txBuffer) == false)
                    {
                        printf(" Failed \r\n");
                    }
                    break;
				case '4':
                    memset(txFiFo, 0x00, CAN1_TX_FIFO_BUFFER_ELEMENT_SIZE);
                    txBuffer = (CAN_TX_BUFFER *)txFiFo;
					txBuffer->id = WRITE_ID(0x469);
                    txBuffer->dlc = 8;
					for (loop_count = 0; loop_count < 8; loop_count++){
						txBuffer->data[loop_count] = loop_count;
					}                
 					printf("  4: Send normal standard message with ID: 0x469 and 8 byte data 0 to 7.\r\n");
					CAN1_TxFifoCallbackRegister( APP_CAN_TxFifoCallback, (uintptr_t)APP_STATE_CAN_TRANSMIT );
                    state = APP_STATE_CAN_IDLE;
					if (CAN1_MessageTransmitFifo(1, txBuffer) == false)
                    {
                        printf(" Failed \r\n");
                    }             
                    break;
				case 'm':
				case 'M':
					display_menu();
					break;
					
				default:
					printf(" Invalid Input \r\n");
					break;
            }
        }

        /* Check the application's current state. */
        switch (state)
        {
            case APP_STATE_CAN_IDLE:
            {
                /* Application can do other task here */
                break;
            }
            case APP_STATE_CAN_XFER_SUCCESSFUL:
            {
                if ((APP_STATES)xferContext == APP_STATE_CAN_TRANSMIT)
                {
                    printf(" Success\r\n");
                }                
                state = APP_STATE_CAN_USER_INPUT;
                break;
            }
            case APP_STATE_CAN_XFER_ERROR:
            {
                if ((APP_STATES)xferContext == APP_STATE_CAN_RECEIVE)
                {
                    printf(" Error in received message\r\n");
                }
                else
                {
                    printf(" Failed\r\n");
                }
                state = APP_STATE_CAN_USER_INPUT;
                break;
            }
            default:
            {
                break;
            }
        }
    }

    /* Execution should not come here during normal operation */

    return ( EXIT_FAILURE );
}

```

**Library Interface**

Control Area Network peripheral library provides the following interfaces:

**Functions**

|Name|Description|
|----|-----------|
|CANx\_Initialize|Initializes given instance of the CAN peripheral|
|CANx\_MessageTransmit|Transmits a message into CAN bus from the specific Tx buffer|
|CANx\_MessageTransmitFifo|Transmit multiple messages into CAN bus from Tx FIFO|
|CANx\_TxFifoFreeLevelGet|Returns Tx FIFO Free Level|
|CANx\_TxBufferIsBusy|Check if Transmission request is pending for the specific Tx buffer|
|CANx\_TxEventFifoRead|Read Tx Event FIFO for the transmitted messages|
|CANx\_TxEventFifoFillLevelGet|Returns Tx Event FIFO Fill Level|
|CANx\_MessageReceive|Read a message from the specific Rx Buffer|
|CANx\_RxBufferNumberGet|Get Rx Buffer Number|
|CANx\_MessageReceiveFifo|Read messages from Rx FIFO0/FIFO1|
|CANx\_RxFifoFillLevelGet|Returns Rx FIFO0/FIFO1 Fill Level|
|CANx\_ErrorGet|Returns the error during transfer|
|CANx\_ErrorCountGet|Returns the transmit and receive error count during transfer|
|CANx\_InterruptGet|Returns the Interrupt status|
|CANx\_InterruptClear|Clears Interrupt status|
|CANx\_MessageRAMConfigSet|Set the Message RAM Configuration|
|CANx\_StandardFilterElementSet|Set a standard filter element configuration|
|CANx\_StandardFilterElementGet|Get a standard filter element configuration|
|CANx\_ExtendedFilterElementSet|Set a Extended filter element configuration|
|CANx\_ExtendedFilterElementGet|Get a Extended filter element configuration|
|CANx\_SleepModeEnter|Puts the CAN Peripheral in sleep mode \(clock stop request\)|
|CANx\_SleepModeExit|Exits CAN peripheral from sleep mode \(clock stop request\)|
|CANx\_TxBuffersCallbackRegister|Sets the pointer to the function \(and it's contextHandle\) to be called when the given CAN's Tx transfer events occur|
|CANx\_TxFifoCallbackRegister|Sets the pointer to the function \(and it's contextHandle\) to be called when the given CAN's Tx transfer events occur|
|CANx\_TxEventFifoCallbackRegister|Sets the pointer to the function \(and it's contextHandle\) to be called when the given CAN's Tx transfer events occur|
|CANx\_RxBuffersCallbackRegister|Sets the pointer to the function \(and it's contextHandle\) to be called when the given CAN's Rx transfer events occur|
|CANx\_RxFifoCallbackRegister|Sets the pointer to the function \(and it's contextHandle\) to be called when the given CAN's Rx transfer events occur|

**Data types and constants**

|Name|Type|Description|
|----|----|-----------|
|CAN\_RX\_FIFO\_NUM|Enum|CAN Rx FIFO Number|
|CAN\_INTERRUPT\_MASK|Enum|CAN Interrupt Mask|
|CAN\_ERROR|Typedef|CAN Transfer Error data type|
|CAN\_TX\_FIFO\_CALLBACK|Typedef|CAN Callback Function Pointer for Tx FIFO|
|CAN\_TXRX\_BUFFERS\_CALLBACK|Typedef|CAN Callback Function Pointer for TX/RX Buffers|
|CAN\_TX\_EVENT\_FIFO\_CALLBACK|Typedef|CAN Callback Function Pointer for Tx Event FIFO|
|CAN\_RX\_FIFO\_CALLBACK|Typedef|CAN Callback Function Pointer for Rx FIFO0/FIFO1|
|CAN\_MSG\_RAM\_CONFIG|Struct|CAN Message RAM Configuration structure|
|CAN\_RX\_BUFFER|Struct|CAN Rx Buffer and FIFO Element Structure|
|CAN\_TX\_BUFFER|Struct|CAN Tx Buffer Element Structure|
|CAN\_TX\_EVENT\_FIFO|Struct|CAN Tx Event FIFO Element Structure|
|CAN\_TX\_FIFO\_CALLBACK\_OBJ|Struct|CAN transfer event callback structure for Tx FIFO|
|CAN\_TXRX\_BUFFERS\_CALLBACK\_OBJ|Struct|CAN transfer event callback structure for Tx/Rx Buffers|
|CAN\_TX\_EVENT\_FIFO\_CALLBACK\_OBJ|Struct|CAN transfer event callback structure for Tx Event FIFO|
|CAN\_RX\_FIFO\_CALLBACK\_OBJ|Struct|CAN transfer event callback structure for Rx FIFO0/FIFO1|

-   **[CANx\_Initialize Function](GUID-3E146A1F-2790-4E35-9A57-92D94CDA1B7A.md)**  

-   **[CANx\_MessageTransmit Function](GUID-F8FB08F1-1020-4E0E-B699-D668F76EE4CC.md)**  

-   **[CANx\_MessageTransmitFifo Function](GUID-8E1F6EF7-F69C-49E8-A8D5-61A4C74F0547.md)**  

-   **[CANx\_TxFifoFreeLevelGet Function](GUID-8BD46231-ABFB-42DF-BDD3-9490B48C6169.md)**  

-   **[CANx\_TxBufferIsBusy Function](GUID-5AD6B3EA-7B70-418A-B61D-716E9B05D8CC.md)**  

-   **[CANx\_TxEventFifoRead Function](GUID-D23A9D95-9F6B-4FB3-A95B-605134CBDA47.md)**  

-   **[CANx\_TxEventFifoFillLevelGet Function](GUID-E5487735-E33E-488B-A6DF-85D9EAF6C68B.md)**  

-   **[CANx\_MessageReceive Function](GUID-AB451CE2-D96C-445A-8F97-8B9565AB2BF7.md)**  

-   **[CANx\_RxBufferNumberGet Function](GUID-9BCF81BA-AC40-4E55-AEED-267C484DF0A5.md)**  

-   **[CANx\_MessageReceiveFifo Function](GUID-F169EF54-C6C1-41C9-8614-3275F52A6AF2.md)**  

-   **[CANx\_RxFifoFillLevelGet Function](GUID-12BD84B9-D2DD-452A-A233-4C93E83C2300.md)**  

-   **[CANx\_ErrorGet Function](GUID-132D09D6-406E-49B7-893E-81AC3DA848DF.md)**  

-   **[CANx\_ErrorCountGet Function](GUID-C47468D6-2A6E-41E6-B936-72567DF52D2B.md)**  

-   **[CANx\_InterruptGet Function](GUID-403171E7-428F-41E9-99DB-0EAF210A1BB4.md)**  

-   **[CANx\_InterruptClear Function](GUID-08752D1C-FC31-48FE-B9B2-D9BC150DBC91.md)**  

-   **[CANx\_MessageRAMConfigSet Function](GUID-09F3243C-9F9D-491B-A064-AF8A125E658A.md)**  

-   **[CANx\_StandardFilterElementSet Function](GUID-14A441DD-8522-45FC-8110-F4D95C0B57DE.md)**  

-   **[CANx\_StandardFilterElementGet Function](GUID-2C241E84-78B5-4F2E-AF92-C7D9F4B732F3.md)**  

-   **[CANx\_ExtendedFilterElementSet Function](GUID-91ADB85B-DD96-4605-A2DA-C140D31A63A1.md)**  

-   **[CANx\_ExtendedFilterElementGet Function](GUID-FA75531C-C56D-4E79-B5F7-36F05E94BA8A.md)**  

-   **[CANx\_SleepModeEnter Function](GUID-80BF65D5-4BDB-4258-B7E4-A36C16BD1FBC.md)**  

-   **[CANx\_SleepModeExit Function](GUID-5B669F57-8686-4ECB-BCA1-454551448648.md)**  

-   **[CANx\_TxBuffersCallbackRegister Function](GUID-A37D5E95-A823-4364-B27E-62B295F946EA.md)**  

-   **[CANx\_TxFifoCallbackRegister Function](GUID-3346EF42-062C-4CB1-AA6D-1DE2921B97A5.md)**  

-   **[CANx\_TxEventFifoCallbackRegister Function](GUID-5AD79E47-F730-402F-85BB-3CB2E5246CAF.md)**  

-   **[CANx\_RxBuffersCallbackRegister Function](GUID-F8AFAF93-FF68-4001-988B-E14646CA1A8F.md)**  

-   **[CANx\_RxFifoCallbackRegister Function](GUID-69FEF87F-BA70-4BBD-BD45-95FBA230CC61.md)**  

-   **[CAN\_RX\_FIFO\_NUM Enum](GUID-DB80C7BE-4CFF-46DE-845A-6472A5C3152F.md)**  

-   **[CAN\_INTERRUPT\_MASK Enum](GUID-008CE3FF-5278-4CBC-9FE9-01362724FD2E.md)**  

-   **[CAN\_ERROR Enum](GUID-3D3073B7-75FE-4ED4-8A1D-BE7E1B6EECFF.md)**  

-   **[CAN\_TX\_FIFO\_CALLBACK Typedef](GUID-7465377D-8192-4186-BBE3-D5345ECD2070.md)**  

-   **[CAN\_TXRX\_BUFFERS\_CALLBACK Typedef](GUID-1F930E12-C996-4736-937D-59B3A98DB3C7.md)**  

-   **[CAN\_TX\_EVENT\_FIFO\_CALLBACK Typedef](GUID-A9BA58CA-7E81-4A85-8D89-909A2B444C51.md)**  

-   **[CAN\_RX\_FIFO\_CALLBACK Typedef](GUID-126660F5-815D-4EC7-B6AB-6AA228086203.md)**  

-   **[CAN\_MSG\_RAM\_CONFIG Struct](GUID-55AE04C4-22CD-41FF-A056-725BBFC97F2F.md)**  

-   **[CAN\_RX\_BUFFER Struct](GUID-707F74FD-6DFF-436E-89C8-7CAC0C3792B4.md)**  

-   **[CAN\_TX\_BUFFER Struct](GUID-9AD285B6-04E0-469D-888B-766188049A31.md)**  

-   **[CAN\_TX\_EVENT\_FIFO Struct](GUID-1BACF3C7-4AEF-449C-B020-799F103061BE.md)**  

-   **[CAN\_TX\_FIFO\_CALLBACK\_OBJ Struct](GUID-08A7435B-5191-4992-A679-B4EA943E1238.md)**  

-   **[CAN\_TXRX\_BUFFERS\_CALLBACK\_OBJ Struct](GUID-378947D0-A175-43BA-A6DB-220712C1511A.md)**  

-   **[CAN\_TX\_EVENT\_FIFO\_CALLBACK\_OBJ Struct](GUID-8880BEF9-34E2-4D23-BBEE-F11B81E5A001.md)**  

-   **[CAN\_RX\_FIFO\_CALLBACK\_OBJ Struct](GUID-6A6D3A45-4E14-4450-BEF3-F49A80E6FC2F.md)**  


**Parent topic:**[PIC32CM JH00 JH01 Peripheral Libraries](GUID-05924E45-D6B3-4F33-A5EA-9B080FC421D8.md)

**Parent topic:**[PIC32CZ-CA Peripheral Libraries](GUID-7EAC3718-3D58-4007-AB2A-A0E3C167A2DF.md)

**Parent topic:**[SAM C20 C21 Peripheral Libraries](GUID-49072E61-B7F2-4B32-952E-D6F5FB361AFB.md)

**Parent topic:**[SAM D51 E51 E53 E54 Peripheral Libraries](GUID-E33B93DD-6680-477E-AA96-966208DC9A50.md)

