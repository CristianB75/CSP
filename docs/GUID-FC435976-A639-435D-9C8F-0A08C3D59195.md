# Direct Memory Access Controller \(DMA\)

The DMA Controller \(DMAC\) can transfer data between memories and<br />peripherals, and thus off-load these tasks from the CPU. It enables<br />high data transfer rates with minimum CPU intervention, and frees up<br />CPU time. With access to all peripherals, the DMAC can handle automatic<br />transfer of data between communication modules. DMAC has several DMA<br />channels and each channel is fully programmable and provides both<br />peripheral or memory-to-memory transfers.

**Using The Library**

DMA Memory to Peripheral and Peripheral to Memory transfer:

```c
\#define MINIMUM_DMA_BUFFER_SIZE                 (32)
\#define NUM_BYTES_TO_READ                       (10)
\#define LED_ON                                  LED0_Clear
\#define LED_OFF                                 LED0_Set

static __attribute__ ((aligned (32))) char startMessage[192] =
"**** DMAC USART echo demo ****\\r\\n\\
\**** Type a buffer of 10 characters and observe it echo back using DMA ****\\r\\n\\
\**** LED toggles each time the buffer is echoed ****\\r\\n";

static __attribute__ ((aligned (32))) char receiveBuffer[MINIMUM_DMA_BUFFER_SIZE] = {0};
static __attribute__ ((aligned (32))) char echoBuffer[MINIMUM_DMA_BUFFER_SIZE] = {0};


static volatile bool writeComplete = false;
static volatile bool readComplete = false;

static void TransmitCompleteCallback(DMA_TRANSFER_EVENT event, uintptr_t contextHandle)
{
    if (event & DMA_TRANSFER_EVENT_BLOCK_TRANSFER_COMPLETE)
    {
        writeComplete = true;
    }
}

static void ReceiveCompleteCallback(DMA_TRANSFER_EVENT event, uintptr_t contextHandle)
{
    if (event & DMA_TRANSFER_EVENT_BLOCK_TRANSFER_COMPLETE)
    {
        readComplete = true;
    }
}

int main ( void )
{
    /* Initialize all modules */
    SYS_Initialize ( NULL );

    DMA_ChannelCallbackRegister(DMA_CHANNEL_0, TransmitCompleteCallback, 0);
    DMA_ChannelCallbackRegister(DMA_CHANNEL_1, ReceiveCompleteCallback, 0);

    /* Clean cache before submitting DMA request, to move data from data cache to main memory */
    DCACHE_CLEAN_BY_ADDR((uint32_t *)startMessage, strlen(startMessage));
    DMA_ChannelTransfer(DMA_CHANNEL_0, startMessage, (const void *)&SERCOM5_REGS-\>USART_INT.SERCOM_DATA, strlen(startMessage));

    while ( true )
    {
        if(readComplete == true)
        {
            /* Echo back received buffer and Toggle LED */
            readComplete = false;

            memcpy(echoBuffer, receiveBuffer, NUM_BYTES_TO_READ);
            echoBuffer[NUM_BYTES_TO_READ] = '\\r';
            echoBuffer[NUM_BYTES_TO_READ + 1] ='\\n';

            /* Clean cache before submitting DMA request, to move data from data cache to main memory */
            DCACHE_CLEAN_BY_ADDR((uint32_t *)echoBuffer, (NUM_BYTES_TO_READ + 2));

            DMA_ChannelTransfer(DMA_CHANNEL_0, echoBuffer, (const void *)&SERCOM5_REGS-\>USART_INT.SERCOM_DATA, (NUM_BYTES_TO_READ + 2));
            LED0_Toggle();
        }
        else if(writeComplete == true)
        {
            /* Now, submit DMA request to read user data */
            writeComplete = false;

            /* Invalidate cache lines before submitting DMA read request */
            DCACHE_INVALIDATE_BY_ADDR((uint32_t *)receiveBuffer, NUM_BYTES_TO_READ);

            DMA_ChannelTransfer(DMA_CHANNEL_1, (const void *)&SERCOM5_REGS-\>USART_INT.SERCOM_DATA, receiveBuffer, NUM_BYTES_TO_READ);
        }
        else
        {
            /* Repeat the loop */
            ;
        }
    }

    /* Execution should not come here during normal operation */

    \return ( EXIT_FAILURE );
}
```

DMA Memory to Memory transfer:

```c
\#define LED_On      LED0_Clear
\#define LED_Off     LED0_Set

\#define TRANSFER_SIZE 1024

__attribute__ ((aligned (32))) uint8_t srcBuffer[TRANSFER_SIZE] = {0};
__attribute__ ((aligned (32))) uint8_t dstBuffer[TRANSFER_SIZE] = {0};

volatile bool dmaXferDone = false;
volatile bool dmaXferError = false;

void DMA_EventHandler(DMA_TRANSFER_EVENT status, uintptr_t context)
{
    if(status & DMA_TRANSFER_EVENT_BLOCK_TRANSFER_COMPLETE)
    {
        dmaXferDone = true;
    }
    else if (status & DMA_TRANSFER_EVENT_ERROR)
    {
        dmaXferError = true;
    }
}

int main ( void )
{
    uint32_t i = 0;

    /* Initialize all modules */
    SYS_Initialize ( NULL );
    LED_Off();

    /* Build the srcBuffer */
    for (i = 0; i \< TRANSFER_SIZE; i++)
    {
        srcBuffer[i] = i;
    }

    printf("\\n\\r-------------------------------------------------------------");
    printf("\\n\\r\\t\\t DMA Memory Transfer DEMO\\t\\t");
    printf("\\n\\r-------------------------------------------------------------");

    /* Register a callback with DMA PLIB to get transfer complete and error events. */
    DMA_ChannelCallbackRegister(DMA_CHANNEL_0, DMA_EventHandler, 0);

    /* Clean cache lines having source buffer before submitting a transfer
     \* request to DMA to load the latest data in the cache to the actual
     \* memory */
    DCACHE_CLEAN_BY_ADDR((uint32_t *)srcBuffer, TRANSFER_SIZE);

    /* Invalidate cache lines before submitting DMA request */
    DCACHE_INVALIDATE_BY_ADDR((uint32_t *)dstBuffer, TRANSFER_SIZE);

    DMA_ChannelTransfer(DMA_CHANNEL_0, srcBuffer, dstBuffer, TRANSFER_SIZE);

    while (dmaXferDone == false && dmaXferError == false);

    if(dmaXferDone == true)
    {
        dmaXferDone = false;

        if(memcmp(srcBuffer, dstBuffer, TRANSFER_SIZE) == 0)
        {
            /* Successfully transferred the data using DMAC */
            printf("\\n\\r DMA Memory Transfer Successful with Data Match\\n\\r");
            LED_On();
        }
        else
        {
            /* Data transfers done, but data mismatch occurred */
            printf("\\n\\r DMA Memory Transfer Successful with Data Mismatch !!!\\n\\r");
            LED_Off();
        }
    }
    else if(dmaXferError == true)
    {
        /* Error occurred during the transfers */
        dmaXferError = false;
        printf("\\n\\r DMA Memory Transfer Error !!!\\n\\r");
        LED_Off();
    }
    else
    {
        /* Nothing to do, loop */
        ;
    }

    while (1)
    {

    }

    /* Execution should not come here during normal operation */

    \return ( EXIT_FAILURE );
}
```

DMA Linked List transfer:

```c
\#define SRC_BUFF1_SIZE                  32
\#define SRC_BUFF2_SIZE                  128
\#define SRC_BUFF3_SIZE                  256

\#define DST_BUFF_SIZE                   (SRC_BUFF1_SIZE + SRC_BUFF2_SIZE + SRC_BUFF3_SIZE)


static DMA_DESCRIPTOR_REGS dmaDescRegs[3] = {0};
static volatile bool dmaLLXferDone = false;
static volatile bool dmaXferError = false;

static __attribute__ ((aligned (32))) uint8_t srcBuffer1[SRC_BUFF1_SIZE];
static __attribute__ ((aligned (32))) uint8_t srcBuffer2[SRC_BUFF2_SIZE];
static __attribute__ ((aligned (32))) uint8_t srcBuffer3[SRC_BUFF3_SIZE];

static __attribute__ ((aligned (32))) uint8_t dstBuffer[DST_BUFF_SIZE];

void DMA_EventHandler(DMA_TRANSFER_EVENT status, uintptr_t context)
{
    if(status & DMA_TRANSFER_EVENT_LINKED_LIST_TRANSFER_COMPLETE)
    {
        dmaLLXferDone = true;
    }
    else if (status & DMA_TRANSFER_EVENT_ERROR)
    {
        dmaXferError = true;
    }
}

void DMA_LinkedListDescSetup(void)
{
    dmaDescRegs[0].DMA_BDNXT = (uint32_t)&dmaDescRegs[1];

    dmaDescRegs[0].DMA_BDCFG.SSA = 1;
    dmaDescRegs[0].DMA_BDCFG.DSA = 1;
    dmaDescRegs[0].DMA_BDCFG.XSIZ = 1;
    dmaDescRegs[0].DMA_BDCFG.ENABLE = 1;
    dmaDescRegs[0].DMA_BDCFG.LLEN = 1;
    dmaDescRegs[0].DMA_BDCFG.SWFRC = 1;
    dmaDescRegs[0].DMA_BDSSA = (uint32_t)srcBuffer1;
    dmaDescRegs[0].DMA_BDDSA = (uint32_t)&dstBuffer[0];
    dmaDescRegs[0].DMA_BDXSIZ.CSZ = 1;
    dmaDescRegs[0].DMA_BDXSIZ.BLKSZ = SRC_BUFF1_SIZE;

    /*------------------------------------------------------*/
    dmaDescRegs[1].DMA_BDNXT = (uint32_t)&dmaDescRegs[2];

    dmaDescRegs[1].DMA_BDCFG.SSA = 1;
    dmaDescRegs[1].DMA_BDCFG.DSA = 1;
    dmaDescRegs[1].DMA_BDCFG.XSIZ = 1;
    dmaDescRegs[1].DMA_BDCFG.ENABLE = 1;
    dmaDescRegs[1].DMA_BDCFG.LLEN = 1;
    dmaDescRegs[1].DMA_BDCFG.SWFRC = 1;
    dmaDescRegs[1].DMA_BDSSA = (uint32_t)srcBuffer2;
    dmaDescRegs[1].DMA_BDDSA = (uint32_t)&dstBuffer[SRC_BUFF1_SIZE];
    dmaDescRegs[1].DMA_BDXSIZ.CSZ = 1;
    dmaDescRegs[1].DMA_BDXSIZ.BLKSZ = SRC_BUFF2_SIZE;

    /*------------------------------------------------------*/
    dmaDescRegs[2].DMA_BDNXT = 0xFFFFFFFF;

    dmaDescRegs[2].DMA_BDCFG.SSA = 1;
    dmaDescRegs[2].DMA_BDCFG.DSA = 1;
    dmaDescRegs[2].DMA_BDCFG.XSIZ = 1;
    dmaDescRegs[2].DMA_BDCFG.ENABLE = 1;
    dmaDescRegs[2].DMA_BDCFG.LLEN = 0;
    dmaDescRegs[2].DMA_BDCFG.SWFRC = 1;
    dmaDescRegs[2].DMA_BDSSA = (uint32_t)srcBuffer3;
    dmaDescRegs[2].DMA_BDDSA = (uint32_t)&dstBuffer[SRC_BUFF1_SIZE + SRC_BUFF2_SIZE];
    dmaDescRegs[2].DMA_BDXSIZ.CSZ = 1;
    dmaDescRegs[2].DMA_BDXSIZ.BLKSZ = SRC_BUFF3_SIZE;
}

void initSourceBuffers(void)
{
    uint32_t i;

    for (i = 0; i \< SRC_BUFF1_SIZE; i++ )
    {
        srcBuffer1[i] = i;
    }
    for (i = 0; i \< SRC_BUFF2_SIZE; i++ )
    {
        srcBuffer2[i] = i;
    }
    for (i = 0; i \< SRC_BUFF3_SIZE; i++ )
    {
        srcBuffer3[i] = i;
    }
}

int main ( void )
{
    /* Initialize all modules */
    SYS_Initialize ( NULL );

    printf("\\n\\r-------------------------------------------------------------");
    printf("\\n\\r\\t DMA Memory Transfer Using Linked Lists \\t\\t");
    printf("\\n\\r-------------------------------------------------------------");

    DMA_ChannelCallbackRegister(DMA_CHANNEL_0, DMA_EventHandler, 0);

    initSourceBuffers();

    /* Clean cache lines to push data into the main memory */
    DCACHE_CLEAN_BY_ADDR((uint32_t *)srcBuffer1, SRC_BUFF1_SIZE);

    DCACHE_CLEAN_BY_ADDR((uint32_t *)srcBuffer2, SRC_BUFF2_SIZE);

    DCACHE_CLEAN_BY_ADDR((uint32_t *)srcBuffer3, SRC_BUFF3_SIZE);

    /* Invalidate cache lines before submitting DMA request */
    DCACHE_INVALIDATE_BY_ADDR((uint32_t *)dstBuffer, DST_BUFF_SIZE);

    DMA_LinkedListDescSetup();

    DMA_ChannelLinkedListTransfer(DMA_CHANNEL_0, dmaDescRegs);

    while (dmaLLXferDone == false && dmaXferError == false);

    if (dmaLLXferDone == true)
    {
        if ( (memcmp(srcBuffer1, &dstBuffer[0], SRC_BUFF1_SIZE) == 0) &&
             (memcmp(srcBuffer2, &dstBuffer[SRC_BUFF1_SIZE], SRC_BUFF2_SIZE) == 0) &&
             (memcmp(srcBuffer3, &dstBuffer[SRC_BUFF1_SIZE + SRC_BUFF2_SIZE], SRC_BUFF3_SIZE) == 0)
        )
        {
            printf("\\n\\r DMA linked list transfer successful with data match\\r\\n");
        }
        else
        {
            printf("\\n\\r DMA linked list error - data mismatch\\r\\n");
        }
    }
    else
    {
        printf("\\n\\r DMA linked list transfer error\\r\\n");
    }

    while ( true )
    {

    }

    /* Execution should not come here during normal operation */

    \return ( EXIT_FAILURE );
}
```

DMA Abort on Pattern Match:

```c
\#define LED_ON                                  LED0_Clear
\#define LED_OFF                                 LED0_Set

\#define USART_RECEIVE_CHANNEL                   DMA_CHANNEL_0
\#define USART_TRANSMIT_CHANNEL                  DMA_CHANNEL_1

\#define MINIMUM_DMA_BUFFER_SIZE                 (32)
\#define NUM_BYTES_TO_READ                       (20)

static __attribute__ ((aligned (32))) char startMessage[192] =
"*** DMA USART echo demo ***\\r\\n\\
\*** Press Enter key to terminate the DMA transfer ***\\r\\n\\
\*** Maximum number of characters entered must be less than 20 ***\\r\\n";

static __attribute__ ((aligned (32))) char receiveBuffer[MINIMUM_DMA_BUFFER_SIZE] = {0};
static __attribute__ ((aligned (32))) char echoBuffer[MINIMUM_DMA_BUFFER_SIZE] = {0};

volatile bool writeComplete = false;
volatile bool readComplete = false;

const uint8_t new_line_ch = 0x0A;

static void TransmitCompleteCallback(DMA_TRANSFER_EVENT event, uintptr_t contextHandle)
{
    if (event & DMA_TRANSFER_EVENT_BLOCK_TRANSFER_COMPLETE)
    {
        writeComplete = true;
    }
}

static void ReceiveCompleteCallback(DMA_TRANSFER_EVENT event, uintptr_t contextHandle)
{
    if (event & DMA_TRANSFER_EVENT_BLOCK_TRANSFER_COMPLETE)
    {
        readComplete = true;
    }
}

int main ( void )
{
    /* Initialize all modules */
    SYS_Initialize ( NULL );

    /* Clean cache before submitting DMA request, to move data from data cache to main memory */
    DCACHE_CLEAN_BY_ADDR((uint32_t *)startMessage, strlen(startMessage));

    /* Transmit the startMessage before turning on the pattern match */
    DMA_ChannelTransfer(USART_TRANSMIT_CHANNEL, (const void *)startMessage, (const void *)&SERCOM5_REGS-\>USART_INT.SERCOM_DATA, sizeof(startMessage));

    while (DMA_ChannelIsBusy(USART_TRANSMIT_CHANNEL));

    DMA_ChannelCallbackRegister(USART_TRANSMIT_CHANNEL, TransmitCompleteCallback,0);
    DMA_ChannelCallbackRegister(USART_RECEIVE_CHANNEL, ReceiveCompleteCallback,0);

    /* data reception from user will stop as soon as "Enter" key is pressed (pattern is matched) */
    DMA_ChannelPatternMatchSetup(USART_RECEIVE_CHANNEL, DMA_PATTERN_MATCH_LEN_1BYTE, (uint16_t)(0x0D));

    DMA_ChannelPatternMatchSetup(USART_TRANSMIT_CHANNEL, DMA_PATTERN_MATCH_LEN_1BYTE, (uint16_t)(0x0D));

    /* Submit buffer to read user data */
    DMA_ChannelTransfer(USART_RECEIVE_CHANNEL, (const void *)&SERCOM5_REGS-\>USART_INT.SERCOM_DATA, (const void *)receiveBuffer, NUM_BYTES_TO_READ);

    while ( true )
    {
        if(readComplete == true)
        {
            /* Echo back received buffer and Toggle LED */
            readComplete = false;

            memcpy(echoBuffer, receiveBuffer, NUM_BYTES_TO_READ);

            /* Clean cache before submitting DMA request, to move data from data cache to main memory */
            DCACHE_CLEAN_BY_ADDR((uint32_t *)echoBuffer, NUM_BYTES_TO_READ);

            /* Since pattern matching is enabled on DMA USART TX channel, this should terminate transfer when 0x0D is found */
            DMA_ChannelTransfer(USART_TRANSMIT_CHANNEL, (const void *)echoBuffer, (const void *)&SERCOM5_REGS-\>USART_INT.SERCOM_DATA, NUM_BYTES_TO_READ);
            LED0_Toggle();
        }
        else if(writeComplete == true)
        {
            writeComplete = false;

            /* Ensure to add new line character on the console before receiving the next data from user */
            DMA_ChannelTransfer(USART_TRANSMIT_CHANNEL, (const void *)&new_line_ch, (const void *)&SERCOM5_REGS-\>USART_INT.SERCOM_DATA, 1);
            while(writeComplete == false);

            writeComplete = false;

            /* Invalidate cache lines before submitting DMA read request */
            DCACHE_INVALIDATE_BY_ADDR((uint32_t *)receiveBuffer, NUM_BYTES_TO_READ);

            /* Submit buffer to read user data */
            DMA_ChannelTransfer(USART_RECEIVE_CHANNEL, (const void *)&SERCOM5_REGS-\>USART_INT.SERCOM_DATA, (const void *)receiveBuffer, NUM_BYTES_TO_READ);
        }
        else
        {
            /* Repeat the loop */
            ;
        }
    }

    /* Execution should not come here during normal operation */

    \return ( EXIT_FAILURE );
}
```

**Library Interface**

Direct Memory Access Controller peripheral library provides the following interfaces:

**Functions**

|Name|Description|
|----|-----------|
|DMA\_Initialize|Initializes the DMA controller of the device|
|DMA\_ChannelCallbackRegister|This function allows a DMA PLIB client to set an event handler|
|DMA\_ChannelTransfer|Schedules a DMA transfer on the specified DMA channel|
|DMA\_ChannelIsBusy|The function returns the busy status of the channel|
|DMA\_ChannelDisable|The function disables the specified DMA channel|
|DMA\_ChannelEnable|The function enables the specified DMA channel|
|DMA\_ChannelGetTransferredCount|Returns transfer count of the ongoing DMA transfer|
|DMA\_ChannelInterruptEnable|This API is used to enable DMA channel interrupt|
|DMA\_ChannelInterruptDisable|This API is used to disable DMA channel interrupt|
|DMA\_ChannelInterruptFlagsGet|This API is used to get the DMA channel interrupt flags|
|DMA\_ChannelPatternMatchSetup|This API is used to setup DMA pattern matching|
|DMA\_ChannelPatternMatchEnable|Enable DMA channel pattern matching|
|DMA\_ChannelPatternMatchDisable|Disable DMA channel pattern matching|
|DMA\_ChannelPatternIgnoreByteEnable|Enable DMA channel pattern ignore byte|
|DMA\_ChannelPatternIgnoreByteDisable|Disable DMA channel pattern ignore byte|
|DMA\_ChannelPatternIgnoreValue|Configures the byte to be ignored for pattern matching when it is enabled|
|DMA\_ChannelSettingsGet|Returns the current channel settings for the specified DMA Channel|
|DMA\_ChannelSettingsSet|Changes the current transfer settings of the specified DMA channel|
|DMA\_ChannelLinkedListTransfer|The function submits a list of DMA transfers|

**Data types and constants**

|Name|Type|Description|
|----|----|-----------|
|DMA\_CHANNEL|Enum|Lists the set of channels available for data transfer using DMA|
|DMA\_CHANNEL\_CONFIG|Typedef|Defines the data type for DMA channel configuration|
|DMA\_TRANSFER\_EVENT|Typedef and Macros|Defines the data type and macros for DMA\_TRANSFER\_EVENT|
|DMA\_INT|Typedef and Macros|Defines the data type and macros for DMA\_INT|
|DMA\_PATTERN\_MATCH\_LEN|Enum|Enumeration for DMA pattern match length type|
|DMA\_DESCRIPTOR\_REGS|Struct|DMA linked list descriptor|
|DMA\_CHANNEL\_CALLBACK|Typedef|Pointer to a DMA Transfer Event handler function|

-   **[DMA\_Initialize Function](GUID-C72A8907-A013-4C8C-B826-53CA9126C5AC.md)**  

-   **[DMA\_ChannelCallbackRegister Function](GUID-32367C9E-068C-4109-91EE-B696894A4D22.md)**  

-   **[DMA\_ChannelTransfer Function](GUID-B796952D-2E89-484B-BC7D-09B3563641E7.md)**  

-   **[DMA\_ChannelIsBusy Function](GUID-750803BE-4EC4-4085-BC4B-4712B5CC0CE7.md)**  

-   **[DMA\_ChannelDisable Function](GUID-970FF9F2-181A-4791-A5EC-2A4AF547058C.md)**  

-   **[DMA\_ChannelEnable Function](GUID-2446CC78-BD36-4232-9DDB-C11CB0C52502.md)**  

-   **[DMA\_ChannelGetTransferredCount Function](GUID-4C5884A9-CB37-47C2-93E6-78CC4C3DEEB3.md)**  

-   **[DMA\_ChannelInterruptEnable Function](GUID-096D9849-D0BB-40C7-85D0-E3E339DE107A.md)**  

-   **[DMA\_ChannelInterruptDisable Function](GUID-352D77DD-D3F3-4C20-AFAE-CFFB71B657A4.md)**  

-   **[DMA\_ChannelInterruptFlagsGet Function](GUID-E9FE0A92-7714-4B2A-944C-B868AFEBD512.md)**  

-   **[DMA\_ChannelPatternMatchSetup Function](GUID-53790AC9-C577-4732-B33D-039954C2DF90.md)**  

-   **[DMA\_ChannelPatternMatchEnable Function](GUID-A6776931-A564-4809-B282-8458A81CE435.md)**  

-   **[DMA\_ChannelPatternMatchDisable Function](GUID-FA58AEC7-8C24-47DC-9735-9D461A8BB79B.md)**  

-   **[DMA\_ChannelPatternIgnoreByteEnable Function](GUID-D79526B7-3D33-43C3-854D-17AED6F6D302.md)**  

-   **[DMA\_ChannelPatternIgnoreByteDisable Function](GUID-D6A3E1CF-DF3C-4AD7-9EA1-30FAFA2EE6E6.md)**  

-   **[DMA\_ChannelPatternIgnoreValue Function](GUID-8BE988F6-2960-43AC-A098-C5AF626CE6E4.md)**  

-   **[DMA\_ChannelSettingsGet Function](GUID-1D53A432-F08D-427B-8A23-4F7C34D3B5E6.md)**  

-   **[DMA\_ChannelSettingsSet Function](GUID-B6210E12-5824-458B-B932-48F038485272.md)**  

-   **[DMA\_ChannelLinkedListTransfer Function](GUID-9507101C-224A-4C21-8A01-D1361F497D8B.md)**  

-   **[DMA\_CHANNEL Enum](GUID-09A9C8F4-F2E3-4F64-844E-F4C05179EAE1.md)**  

-   **[DMA\_CHANNEL\_CONFIG Typedef](GUID-3AD9EAD9-E2C5-427D-868D-C734F03D7EEA.md)**  

-   **[DMA\_TRANSFER\_EVENT Typedef and Macros](GUID-B1038333-6EBD-4219-AFDF-5BDCE5B57BC1.md)**  

-   **[DMA\_INT Typedef and Macros](GUID-B889932F-9F36-4AEE-9D2A-9D2714924C04.md)**  

-   **[DMA\_PATTERN\_MATCH\_LEN Enum](GUID-F6641316-60CB-494B-9A6A-1AF5401E63AC.md)**  

-   **[DMA\_DESCRIPTOR\_REGS Struct](GUID-293744D2-F8A8-461B-A8E3-3126784B34C2.md)**  

-   **[DMA\_CHANNEL\_CALLBACK Typedef](GUID-39C60787-28C6-4FFD-A644-A43881AA275B.md)**  


**Parent topic:**[PIC32CZ-CA Peripheral Libraries](GUID-7EAC3718-3D58-4007-AB2A-A0E3C167A2DF.md)

