# Analog-to-Digital Converter \(ADC\)

-   Up to 12-bit resolution of the numerical output, signed or unsigned

-   Signed outputs left- or right-adjusted

-   Up to 5.14 Msps conversion rate per channel

-   Up to 4 Shared Analog ADC SAR cores \(bound by limited CSR and pin-out resources\) for an aggregate conversion rate of 20.5 Msps per entire ADC module by performing up to 4 conversions simultaneously

-   Up to 64 analog inputs \(maximum of 16 channels per core\).

-   Single-ended and/or differential inputs on a per channel basis for all channels.

-   Up to 16 trigger sources, off-chip hardware or on-chip hardware or software generated

-   Edge or level active triggering modes, to generate single conversions or bursts of conversions

-   A scan trigger per each shared Analog ADC SAR Core to start a scan cycle which can individually include or not any of the analog inputs assigned to that Analog ADC SAR Core

-   Up to 4 scan cycles running simultaneously

-   Any channel can select any of the 16 trigger sources or the scan trigger as its own trigger

-   The scan trigger itself can select any of the 16 trigger sources as its own source Programmable sampling time, individual for each shared Analog ADC SAR Core

-   Each analog input / channel output register can be read from an general dedicated APB output register \(user writes the CORDYID and CHRDYID then reads the CHRDYDATA register\).


**Using The Library**

**Interrupt mode:**

```c
#include <stddef.h>                     // Defines NULL
#include <stdbool.h>                    // Defines true
#include <stdlib.h>                     // Defines EXIT_FAILURE
#include "definitions.h"                // SYS function prototypes

#define ADC_VREF                             (3.3f)

volatile uint32_t adc_data[3];
volatile bool adc_sequence_done = false;
volatile bool adc_ch2_done = false;
float adc_inp_vol;
// *****************************************************************************
// *****************************************************************************
// Section: Main Entry Point
// *****************************************************************************
// *****************************************************************************
void ADC_EventHandler(ADC_CORE_INT status, uintptr_t context)
{
    /* ADC1_CH0 and ADC1_CH1 are configured for scan trigger */
    if (status & ADC_CORE_INT_EOSRDY)
    {                
        adc_data[0] = ADC_ResultGet(ADC_CORE_NUM1, ADC_CH0);
        
        adc_data[1] = ADC_ResultGet(ADC_CORE_NUM1, ADC_CH1);
        
        adc_sequence_done = true;
    }
    /* ADC1_CH2 is configured for Global (Edge) Software trigger */
    if (status & ADC_CORE_INT_CHRDY_2)
    {
        adc_data[2] = ADC_ResultGet(ADC_CORE_NUM1, ADC_CH2);
        
        adc_ch2_done = true;
    }
}

int main ( void )
{
    /* Initialize all modules */
    SYS_Initialize ( NULL );
    
    printf("\r\n *********************************************** \r\n");
    printf("\r\n           ADC INTERRUPT DEMO \r\n");
    printf("\r\n *********************************************** \r\n");
    
    ADC_CORE1CallbackRegister(ADC_EventHandler, 0);    
    RTC_Timer32Start();

    while ( true )
    {
        if (SWITCH_Get() == 0)
        {
            // Wait for switch release
            while (SWITCH_Get() == 0);
            
            ADC_GlobalEdgeConversionStart();
        }
        
        if (adc_sequence_done == true) 
        {
			adc_sequence_done = false;
                                    
            adc_inp_vol = (uint16_t)adc_data[0] * ADC_VREF / 4095U;
            
            printf("\r\n ADC1_AIN0: ADC Count: 0x%03x, ADC Input Voltage = %d.%02d V \r\n", 
                    (uint16_t)adc_data[0], (int)adc_inp_vol, (int)((adc_inp_vol - (int)adc_inp_vol)*100.0));
            
            adc_inp_vol = (uint16_t)adc_data[1] * ADC_VREF / 4095U;
            
            printf("\r\n ADC1_AIN1: ADC Count: 0x%03x, ADC Input Voltage = %d.%02d V \r\n", 
                    (uint16_t)adc_data[1], (int)adc_inp_vol, (int)((adc_inp_vol - (int)adc_inp_vol)*100.0));
		}       
        if (adc_ch2_done == true)
        {
            adc_ch2_done = false;
            
            adc_inp_vol = (uint16_t)adc_data[2] * ADC_VREF / 4095U;
            
            printf("\r\n ADC1_AIN2: ADC Count: 0x%03x, ADC Input Voltage = %d.%02d V \r\n", 
                    (uint16_t)adc_data[2], (int)adc_inp_vol, (int)((adc_inp_vol - (int)adc_inp_vol)*100.0));
        }
    }

    /* Execution should not come here during normal operation */

    return ( EXIT_FAILURE );
}
```

**Polling mode:**

```c
#include <stddef.h>                     // Defines NULL
#include <stdbool.h>                    // Defines true
#include <stdlib.h>                     // Defines EXIT_FAILURE
#include "definitions.h"                // SYS function prototypes

#define ADC_VREF                             (3.3f)

// *****************************************************************************
// *****************************************************************************
// Section: Main Entry Point
// *****************************************************************************
// *****************************************************************************
uint32_t adc_data;
float adc_inp_vol;

int main ( void )
{
    /* Initialize all modules */
    SYS_Initialize ( NULL );
    
    while ( true )
    {
        ADC_GlobalEdgeConversionStart();
        
        while (ADC_ChannelResultIsReady(ADC_CORE_NUM1, ADC_CH0) == false);
        
        adc_data = ADC_ResultGet(ADC_CORE_NUM1, ADC_CH0);
        
        adc_inp_vol = (uint16_t)adc_data * ADC_VREF / 4095U;
            
        printf("ADC1_AIN0: ADC Count: 0x%03x, ADC Input Voltage = %d.%02d V\r", 
            (uint16_t)adc_data, (int)adc_inp_vol, (int)((adc_inp_vol - (int)adc_inp_vol)*100.0));
    }

    /* Execution should not come here during normal operation */

    return ( EXIT_FAILURE );
}
```

**Library Interface**

ADC Controller peripheral library provides the following interfaces:

**Functions**

|Name|Description|
|----|-----------|
|ADCx\_Initialize|Initializes given instance of ADC peripheral|
|ADCx\_Enable|Enables the ADC module|
|ADCx\_Disable|Disables the ADC module|
|ADC\_CompareEnable|Enables digital comparisons for the given channel on the specified ADC core|
|ADC\_CompareDisable|Disables digital comparisons for the given channel on the specified ADC core|
|ADC\_CompareWinThresholdSet|Configures the low and high threshold values for the comparator on the specified ADC core|
|ADC\_CompareWinModeSet|Configures the low and high threshold values for the comparator on the specified ADC core|
|ADC\_GlobalInterruptsStatusGet|Returns the global interrupt status|
|ADC\_CoreInterruptsEnable|Enables the specified ADC core's interrupt|
|ADC\_CoreInterruptsDisable|Disable the specified ADC core's interrupts|
|ADC\_CoreInterruptsStatusGet|Returns the specified ADC core's interrupt status|
|ADC\_CoreInterruptsStatusClear|Clears the specified ADC core's interrupt status|
|ADC\_GlobalEdgeConversionStart|Generates global edge trigger and starts conversion on channels configured with Global edge as the trigger source|
|ADC\_GlobalLevelConversionStart|Starts global level trigger and starts conversion on channels configured with Global level as the trigger source|
|ADC\_GlobalLevelConversionStop|Stops global level trigger and stops conversion on channels configured with Global level as the trigger source|
|ADC\_SyncTriggerEnable|Enables sync trigger defined by CTRLC.CNT value|
|ADC\_SyncTriggerDisable|Disables sync trigger|
|ADC\_SyncTriggerCounterSet|Configures the value of CTRLC.CNT register|
|ADC\_SoftwareControlledConversionEnable|Enables software controlled conversion on the specified ADC core's channel|
|ADC\_ChannelSamplingStart|Enables the Analog Mux Input and starts sampling on the ADC core and channel that was specified using the ADC\_SoftwareControlledConversionEnable\(\) API|
|ADC\_ChannelSamplingStop|Stops sampling on the ADC core and channel that was specified using the ADC\_SoftwareControlledConversionEnable\(\) API|
|ADC\_ChannelConversionStart|Starts conversion on the ADC core and channel that was specified using the ADC\_SoftwareControlledConversionEnable\(\) API|
|ADC\_ChannelResultIsReady|Indicates whether ADC conversion is complete on the specified ADC core's channel|
|ADC\_EOSStatusGet|Indicates whether End of scan interrupt flag is set on the specified ADC core|
|ADC\_ResultGet|Returns the ADC conversion value for the specified ADC core channel|
|ADC\_FIFORead|Returns a single ADC conversion value from the ADC FIFO|
|ADC\_FIFOBufferRead|Returns multiple ADC conversion values from the ADC FIFO|
|ADC\_GlobalCallbackRegister|Registers the global callback function|
|ADC\_COREnCallbackRegister|Registers the ADC core specific callback function|

**Data types and constants**

|Name|Type|Description|
|----|----|-----------|
|ADC\_CORE\_INT\_CMPHIT|Macro|Identifies ADC core interrupt status|
|ADC\_FIFO\_CORID\_GET|Macro|Returns the ADC core id in the ADC FIFO data|
|ADC\_FIFO\_DATA\_GET|Macro|Returns the ADC conversion resunt from the ADC FIFO data|
|ADC\_FIFO\_CHNID\_GET|Macro|Returns the ADC channel id in the ADC FIFO data|
|ADC\_FIFO\_CNT\_GET|Macro|Returns the current number of entries present in the ADC FIFO|
|ADC\_GLOBAL\_INT\_CRRDY1|Macro|Identifies ADC global interrupt status|
|ADC\_CHANNEL\_NUM|Enum|Identifies ADC channel number|
|ADC\_CORE\_NUM|Enum|Identifies ADC core|
|ADC\_CORE\_CALLBACK|Typedef|Defines the function pointer data type and function signature for the adc peripheral core callback function|
|ADC\_GLOBAL\_CALLBACK|Typedef|Defines the function pointer data type and function signature for the adc peripheral global callback function|
|ADC\_CORE\_CALLBACK\_OBJECT|Struct|ADC Core events Callback structure|
|ADC\_GLOBAL\_CALLBACK\_OBJECT|Struct|ADC Global Callback structure|

-   **[ADCx\_Initialize Function](GUID-396C47E4-A7E5-4E83-B9B2-C1C2D6B38DA0.md)**  

-   **[ADCx\_Enable Function](GUID-3A6F7362-5060-4448-A253-5E155F1FB260.md)**  

-   **[ADCx\_Disable Function](GUID-B8220677-A69F-4451-A8CD-70CF1BEE850A.md)**  

-   **[ADC\_CompareEnable Function](GUID-5E192064-EA6C-4A6F-979F-DEC00DBA7FD3.md)**  

-   **[ADC\_CompareDisable Function](GUID-7197528D-4D9F-4789-B14E-33B501637A2C.md)**  

-   **[ADC\_CompareWinThresholdSet Function](GUID-616F2C50-6026-4AF7-989C-29AA55BD87CD.md)**  

-   **[ADC\_CompareWinModeSet Function](GUID-446475AC-2795-4E50-9121-D89CCDE215FA.md)**  

-   **[ADC\_GlobalInterruptsStatusGet Function](GUID-CA29C309-3440-40F0-8A34-9FFAD3187662.md)**  

-   **[ADC\_CoreInterruptsEnable Function](GUID-9C973AD1-1DA9-4246-AE33-A83DA4E006DB.md)**  

-   **[ADC\_CoreInterruptsDisable Function](GUID-C3532D94-41C7-4588-8C80-CFA5DFCC275A.md)**  

-   **[ADC\_CoreInterruptsStatusGet Function](GUID-DF4481C9-4A88-43F9-B96D-CE16B95B4DE7.md)**  

-   **[ADC\_CoreInterruptsStatusClear Function](GUID-44BE4791-AD1D-40BE-806A-7B74D84CBE6C.md)**  

-   **[ADC\_GlobalEdgeConversionStart Function](GUID-C281FFFB-9A10-45CB-BD21-41E2D876D930.md)**  

-   **[ADC\_GlobalLevelConversionStart Function](GUID-E39C6D21-0F2B-4B12-95CB-C6F1E6ED92DF.md)**  

-   **[ADC\_GlobalLevelConversionStop Function](GUID-FF3F8D06-F9B9-46B2-8DF2-716BF7CFE557.md)**  

-   **[ADC\_SyncTriggerEnable Function](GUID-E6CC5F75-7F4A-4042-A74F-66B74E282FC2.md)**  

-   **[ADC\_SyncTriggerDisable Function](GUID-BEA2DADF-9668-4689-A69B-6C36126BADFC.md)**  

-   **[ADC\_SyncTriggerCounterSet Function](GUID-92947136-2EAC-48E0-AA12-6B8E6546C89F.md)**  

-   **[ADC\_SoftwareControlledConversionEnable Function](GUID-67930B0B-2B40-48B9-AE17-53088F6571FD.md)**  

-   **[ADC\_ChannelSamplingStart Function](GUID-4430E806-5C66-4E6D-9A74-210AE4288C2E.md)**  

-   **[ADC\_ChannelSamplingStop Function](GUID-06012343-14DE-4BD6-8559-7C461C7BAEB8.md)**  

-   **[ADC\_ChannelConversionStart Function](GUID-25EECF8F-A6E1-4329-964A-C3ECAE35E75D.md)**  

-   **[ADC\_ChannelResultIsReady Function](GUID-BB98C900-C5D9-4393-991D-DD40FA2500A1.md)**  

-   **[ADC\_EOSStatusGet Function](GUID-15E8DFD2-A90D-4575-A64E-7FB3C4D158AE.md)**  

-   **[ADC\_ResultGet Function](GUID-18187A2F-87DD-49C8-9F3E-605814181004.md)**  

-   **[ADC\_FIFORead Function](GUID-9ABE7186-B669-42A3-8CDF-709EA3F795C1.md)**  

-   **[ADC\_FIFOBufferRead Function](GUID-C831ADEB-DF15-42C9-A3EA-CBD3943A3FDC.md)**  

-   **[ADC\_GlobalCallbackRegister Function](GUID-7346C245-81E3-4F1C-96CB-BB78E324F652.md)**  

-   **[ADC\_COREnCallbackRegister Function](GUID-DA6926AD-D4C8-4125-AC95-C4E877C8EC05.md)**  

-   **[ADC\_CORE\_INT\_CMPHIT Macro](GUID-F946CB99-B34B-4435-A5E8-8887417855FE.md)**  

-   **[ADC\_FIFO\_CORID\_GET Macro](GUID-90FE6E87-D157-4801-BB43-B8502161913A.md)**  

-   **[ADC\_FIFO\_DATA\_GET Macro](GUID-6682E846-944A-4A91-ACD0-2F5FD161FA45.md)**  

-   **[ADC\_FIFO\_CHNID\_GET Macro](GUID-E8BB6C9E-3D35-43CB-8DDC-B32F27CCBFB3.md)**  

-   **[ADC\_FIFO\_CNT\_GET Macro](GUID-1B9C8272-AC25-44F5-A5C1-2B10A06B79B5.md)**  

-   **[ADC\_GLOBAL\_INT\_CRRDY1 Macro](GUID-61672FB7-2937-4508-84B5-AE954874FC8E.md)**  

-   **[ADC\_CHANNEL\_NUM Enum](GUID-F95C06AB-841F-4195-B216-E534F0AF9B62.md)**  

-   **[ADC\_CORE\_NUM Enum](GUID-76AD9A29-D41B-481D-835F-18D41534137C.md)**  

-   **[ADC\_CORE\_CALLBACK Typedef](GUID-39DC7E3A-76D8-4063-910F-7CBF305A3CA2.md)**  

-   **[ADC\_GLOBAL\_CALLBACK Typedef](GUID-B7907AD4-8126-442D-9079-F461BD966D79.md)**  

-   **[ADC\_CORE\_CALLBACK\_OBJECT Struct](GUID-2EDCB2A8-0603-4E06-9159-4F550E196738.md)**  

-   **[ADC\_GLOBAL\_CALLBACK\_OBJECT Struct](GUID-558D3E26-5F80-469D-AA4E-0C659770DC8A.md)**  


**Parent topic:**[PIC32CZ-CA Peripheral Libraries](GUID-7EAC3718-3D58-4007-AB2A-A0E3C167A2DF.md)

