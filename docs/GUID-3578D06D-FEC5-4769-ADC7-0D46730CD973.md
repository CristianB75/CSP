# Real-Time Counter \(RTC\)

The RTC module is a 32-bit counter, with a 10-bit programmable prescaler. Typically, the RTC clock is run continuously, including in the device's low-power sleep modes, to track the current time and date information. The RTC can be used as a source to wake up the system at a scheduled time or periodically using the alarm functions.The RTC peripheral can be configured to operate in the following three modes:

-   16-bit Counter mode \(or Timer mode\)

-   32-bit Counter mode \(or Timer mode\)

-   Calendar mode


The RTC peripheral in 16-bit or 32-bit counter mode allows for an easy integration of an asynchronous counter into a user application, which is capable of operating while the device is in sleep mode.The RTC peripheral in calendar mode allows for an easy integration of a real time clock and calendar into a user application to track the passing of time and/or perform scheduled tasks.The RTC timer has 10-bit programmable prescaler, it can generate periodic events on the upper eight bits of the RTC prescaler. Table below shows the periodic event frequencies for each prescaler bit using 1 KHz clock.

\| Bit position \| Periodic Event \|<br />\|:------------ \|: --------------\|<br />\| 7 \| 1 Hz \|<br />\| 6 \| 2 Hz \|<br />\| 5 \| 4 Hz \|<br />\| 14 \| 8 Hz \|<br />\| 3 \| 16 Hz \|<br />\| 2 \| 32 Hz \|<br />\| 1 \| 64 Hz \|<br />\| 0 \| 128 Hz \|

**32-bit timer mode\(Mode 0\)**

The RTC counter in 32-bit timer mode will increment until it reaches the top value of 0xFFFFFFFF, and then wrap to 0x00000000 and sets the overflow interrupt. The counter value is continuously compared with the 32-bit Compare register \(COMP0\), and sets the compare match interrupt when compare match occurs. If the Clear on compare match is selected, the counter is cleared when a compare match occurs. Both compare match and overflow interrupt is set on compare match. The Clear on compare match feature allow the RTC to generate periodic interrupts or events with longer periods than the prescaler events.

**Using The Library**

The peripheral library provides polling and callback methods to<br />indicate compare match or timer overflow.

-   With polling, the application will need to continuously poll to check if the compare match has occurred or timer has overflowed

-   With callback, the registered callback function will be called when the compare match occurs or timer overflows \(Application do not have to poll continuously\)


**Callback method**

This example demonstrates how to use RTC to generate periodic callback<br />using clear on compare feature.

```c
/* This function is called after period expires */
void Timeout_Handler(RTC_TIMER32_INT_MASK intCause, uintptr_t context)
{
    if((intCause &amp; RTC_TIMER32_INT_MASK_CMP0) == RTC_TIMER32_INT_MASK_CMP0)
    {
        LED_Toggle();
    }
}

int main(void)
{
    /* Initialize all modules */
    SYS_Initialize ( NULL );
    RTC_Timer32CallbackRegister(Timeout_Handler,0);
    RTC_Timer32InterruptEnable(RTC_TIMER32_INT_MASK_CMP0);
    RTC_Timer32Start();
}
```

**Library Interface**

Real-Time Counter peripheral library provides the following interfaces:

**Functions**

|Name|Description|
|----|-----------|
|RTC\_Initialize|Initialize given instance of the RTC peripheral|
|RTC\_Timer32CompareHasMatched|Check for 32-bit Timer Compare match|
|RTC\_Timer32Compare0HasMatched|Check for 32-bit Timer Compare match|
|RTC\_Timer32Compare1HasMatched|Check for 32-bit Timer Compare match|
|RTC\_Timer32CounterHasOverflowed|Check if the 32-bit counter overflow|
|RTC\_Timer32Start|Starts the 32-bit timer|
|RTC\_Timer32Stop|Stops the 32-bit timer from counting|
|RTC\_Timer32CounterSet|Set the 32-bit Timer Counter Value|
|RTC\_Timer32CompareSet|Set the 32-bit timer period value|
|RTC\_Timer32Compare0Set|Set the 32-bit timer period value|
|RTC\_Timer32Compare1Set|Set the 32-bit timer period value|
|RTC\_Timer32PeriodGet|Get 32-bit timer period Value|
|RTC\_Timer32CounterGet|Get the current 32-bit counter value|
|RTC\_Timer32FrequencyGet|Returns the frequency at which the 32-bit timer counter is operating|
|RTC\_Timer32InterruptEnable|Enable selected RTC interrupt|
|RTC\_Timer32InterruptDisable|Disable selected RTC interrupt|
|RTC\_Timer32CallbackRegister|Register the callback function to be called when an 32-bit Timer Interrupt occurs|
|RTC\_Timer32TimeStampGet|Get the Time stamp of Tamper Detection|
|RTC\_PeriodicIntervalHasCompleted|Check if the configured periodic interval has expired|

**Data types and constants**

|Name|Type|Description|
|----|----|-----------|
|RTC\_TIMER32\_INT\_MASK|Enum|Possible RTC 32-bit Timer Counter Mode Events|
|RTC\_TIMER32\_CALLBACK|Typedef|Defines the data type and function signature of the RTC 32-bit Timer Counter callback function|
|RTC\_PERIODIC\_INT\_MASK|Enum|Possible Periodic Interrupt Mask|

**16-bit timer mode\(Mode 1\)**

The RTC counter in 16-bit timer mode will increment until it matches with 16-bit period value, and then wrap to 0x0000. This sets the the overflow interrupt. The counter value is continuously compared with two 32-bit Compare registers \(Compare 0, Compare 1\), and sets the respective compare match interrupt when compare match occurs. The RTC timer has 10-bit programmable prescaler, it can generate periodic events on the upper eight bits of the RTC prescaler. The resulting periodic frequency is from 1Hz to 128 Hz depending on the selected prescaler bit position to generate periodic interrupt.

**Using The Library**

The peripheral library provides polling and callback methods to indicate compare match or period expiry.

-   With polling, the application will need to continuously poll to check if the compare match has occurred or counter has overflowed.

-   With callback, the registered callback function will be called when the period match or compare match occurs\(his means the application do not have to poll continuously\)


**Callback method**<br />This example demonstrates how to use RTC to generate periodic callback.

```c
/* This function is called after period expires */
void RTC_Callback(RTC_TIMER16_INT_MASK interruptCause, uintptr_t context)
{

    if(interruptCause &  RTC_TIMER16_INT_MASK_PERIOD_MATCH)
    {
        // The period has matched.
        LED_Toggle();
    }

}

int main(void)
{

    /* Register callback function for RTC */
    RTC_Timer16CallbackRegister(RTC_Callback, (uintptr_t)NULL);

    /* Enable Period Interrupt */
    RTC_Timer16InterruptEnable( RTC_TIMER16_INT_MASK_PERIOD_MATCH);

    /* Start RTC Timer */
    RTC_Timer16Start();
}
```

**Functions**

|Name|Description|
|----|-----------|
|RTC\_Initialize|Initialize given instance of the RTC peripheral|
|RTC\_FrequencyCorrect|Calibrate for too-slow or too-fast oscillator|
|RTC\_Timer16CounterHasOverflowed|Checks if the 16-bit counter has overflowed|
|RTC\_Timer16Compare0HasMatched|Returns true if the 16-bit Timer Compare 0 value has matched the counter|
|RTC\_Timer16Compare1HasMatched|Returns true if the 16-bit Timer Compare 1 value has matched the counter|
|RTC\_Timer16Compare2HasMatched|Returns true if the 16-bit Timer Compare 2 value has matched the counter|
|RTC\_Timer16Compare3HasMatched|Returns true if the 16-bit Timer Compare 3 value has matched the counter|
|RTC\_Timer16Start|Starts the 16-bit timer|
|RTC\_Timer16Stop|Stops the 16-bit timer from counting|
|RTC\_Timer16CounterSet|Set the 16-bit Timer Counter Value|
|RTC\_Timer16PeriodSet|Set the 16-bit timer period value|
|RTC\_Timer16PeriodGet|Get 16-bit timer period Value|
|RTC\_Timer16CounterGet|Get the current 16-bit counter value|
|RTC\_Timer16FrequencyGet|Returns the frequency at which the 16-bit timer counter is operating|
|RTC\_Timer16InterruptEnable|Enable Selected RTC interrupt|
|RTC\_Timer16InterruptDisable|Disable Selected RTC Interrupt|
|RTC\_Timer16Compare0Set|Set the 16-Bit Counter Compare 0 Value|
|RTC\_Timer16Compare1Set|Set the 16-Bit Counter Compare 1 Value|
|RTC\_Timer16Compare2Set|Set the 16-Bit Counter Compare 2 Value|
|RTC\_Timer16Compare3Set|Set the 16-Bit Counter Compare 3 Value|
|RTC\_Timer16TimeStampGet|Get the Time stamp of Tamper Detection|
|RTC\_Timer16CallbackRegister|Register the callback function to be called when an 16-bit Timer Interrupt occurs|
|RTC\_PeriodicIntervalHasCompleted|Check if the configured periodic interval has expired|

**Data types and constants**

|Name|Type|Description|
|----|----|-----------|
|RTC\_TIMER16\_INT\_MASK|Enum|Possible RTC 16-bit Timer Counter Mode Events|
|RTC\_TIMER16\_CALLBACK|Typedef|Defines the data type and function signature of the RTC 16-bit Timer Counter callback function|

**Clock and Calendar \(Mode 2\)**

The RTC provides a full binary-coded decimal \(BCD\) clock that includes century \(19/20\), year \(with leap years\), month, day,hours, minutes, and seconds. The RTC can operate in 24-hour mode or in 12-hour mode with an AM/PM indicator. The RTC continues to run in the device's low-power sleep modes, to track the current time and date information. The RTC can be<br />used as a source to wake up the system at a scheduled time or periodically using the alarm functions.

**Using The Library**

The RTC keeps track of the current time and generates an alarm at the desired time. The RTC Alarm has six programmable fields:<br />year, month, date, hours, minutes, and seconds.<br />The alarm mask allows following options to generate alarm.

-   Alarm mask to compare seconds field \(SS\) - Generates alarm once per minute

-   Alarm mask to compare minutes and seconds field \(MMSS\) - Generates alarm once per hour

-   Alarm mask to compare hours, minutes and seconds field \(HHMMSS\) - Generates alarm once per day

-   Alarm mask to compare date, hours, minutes, and seconds field \(DDHHMMSS\) - Generates alarm once per month

-   Alarm mask to compare month, date, hours, minutes and seconds \(MMDDHHMMSS\) - Generates alarm once per year

-   Alarm mask to compare year, month, date, hours, minutes and seconds \(YYMMDDHHMMSS\) - Generates alarm on exact day and time


This example demonstrates how to set the RTC time, and alarm time to generate an alarm interrupt at the desired time of the day.

```c

bool alarm_triggered;

void RTC_Callback(RTC_CLOCK_INT_MASK int_cause , uintptr_t  context)
{
    if (int_cause & RTC_CLOCK_INT_MASK_ALARM)
    {
        alarm_triggered = true;
        LED_Toggle();
    }
}

int main ( void )
{
    /* Initialize System Time and Alarm Time */
    struct tm sys_time;
    struct tm alarm_time;

    /* Register Callback */
    RTC_CallbackRegister(RTC_Callback, (uintptr_t) NULL);


    /* Set Time and date
      15-01-2018 12:00:00 Monday */
    sys_time.tm_hour = 12;      /* hour [0,23] */
    sys_time.tm_sec = 00;       /* seconds [0,61] */
    sys_time.tm_min = 00;       /* minutes [0,59] */
    sys_time.tm_mon = 0;        /* month of year [0,11] */
    sys_time.tm_year = 118;     /* years since 1900 */
    sys_time.tm_mday = 15;      /* day of month [1,31] */
    sys_time.tm_wday = 1;       /* day of week [0,6] (Sunday = 0) */
                                /* tm_yday - day of year [0,365] */
                                /* tm_isdst - daylight savings flag */

    RTC_TimeSet(&sys_time);


    /* Set Alarm Time and date. Generate alarm every day when Hour, Minute and Seconds match.
       15-01-2018 12:00:20 Monday */
    alarm_time.tm_hour = 12;
    alarm_time.tm_sec = 20;
    alarm_time.tm_min = 00;
    alarm_time.tm_mon = 0;
    alarm_time.tm_year = 118;
    alarm_time.tm_mday = 15;
    alarm_time.tm_wday = 1;

    RTC_RTCCAlarmSet(&alarm_time, RTC_ALARM_MASK_HHMMSS);


    while ( true )
    {
        if(alarm_triggered == true)
        {
            printf("\n\rAlarm Triggered !!!!!!!!\n\r");
            alarm_triggered = false;
        }
    }

}

```

**Functions**

|Name|Description|
|----|-----------|
|RTC\_Initialize|Initialize given instance of the RTC peripheral|
|RTC\_RTCCTimeGet|Gets the current time and date|
|RTC\_RTCCTimeSet|Sets the Real Time Clock Calendar time and date|
|RTC\_RTCCAlarmSet|Set an alarm|
|RTC\_RTCCCallbackRegister|Register the callback function to be called when an RTCC Interrupt occurs|
|RTC\_BackupRegisterSet|Set the value for the selected Backup Register|
|RTC\_BackupRegisterGet|Get the value stored in the selected Backup Register|
|RTC\_TamperSourceGet|Get the Tamper source|
|RTC\_RTCCTimeStampGet|Get the Time stamp of Tamper Detection|

**Data types and constants**

|Name|Type|Description|
|----|----|-----------|
|RTC\_ALARM\_MASK|Enum|Possible RTC Alarm Mask Settings|
|RTC\_CLOCK\_EVENT|Enum|Possible RTC RTCC Mode Events|
|BACKUP\_REGISTER|Enum|Possible Backup Register Mask|
|TAMPER\_CHANNEL|Enum|Possible Tamper Channel Mask|
|RTC\_CLOCK\_INT\_MASK|Enum|Possible RTC Clock Mode Events|
|RTC\_CALLBACK|Typedef|Defines the data type and function signature of the Real Time Clock Calendar callback function|

-   **[RTC\_Initialize Function](GUID-8789706F-69A3-4685-8629-AE467DDD8768.md)**  

-   **[RTC\_PeriodicIntervalHasCompleted Function](GUID-8F1BF586-0401-4DC5-A34C-359E61AE8AE0.md)**  

-   **[RTC\_Timer32Compare0HasMatched Function](GUID-3211B524-C3CC-4AE8-8AFC-1E845D2C912B.md)**  

-   **[RTC\_Timer32Compare0Set Function](GUID-22700D5E-B61F-45B4-A2AA-59333F1DE5AC.md)**  

-   **[RTC\_Timer32Compare1HasMatched Function](GUID-C4270FC0-5750-480D-9F3B-7010E71F0B92.md)**  

-   **[RTC\_Timer32Compare1Set Function](GUID-D14FFB39-39D8-4C53-97A8-60F1DD8054D7.md)**  

-   **[RTC\_Timer32TimeStampGet Function](GUID-A4F70D1A-9030-43FF-AC66-07694D340D3A.md)**  

-   **[RTC\_Timer32CallbackRegister Function](GUID-3A37E233-DB94-4FFA-BBF8-5309D1F7E55F.md)**  

-   **[RTC\_Timer32CompareHasMatched Function](GUID-188CDFD7-1672-4623-8535-693F60828F39.md)**  

-   **[RTC\_Timer32CompareSet Function](GUID-00167119-EAC4-485E-B360-5858ACBD1678.md)**  

-   **[RTC\_Timer32CounterGet Function](GUID-1525DFAE-D908-4B16-A4AC-9B2D05D31CEC.md)**  

-   **[RTC\_Timer32CounterHasOverflowed Function](GUID-D351D4C2-A376-4F75-9041-2010B51B473D.md)**  

-   **[RTC\_Timer32CounterSet Function](GUID-C58951CD-E59F-4D1F-8C7B-4E1D1F0EA8AF.md)**  

-   **[RTC\_Timer32FrequencyGet Function](GUID-086FFFAF-7934-43FB-9077-FC1B90BF28B3.md)**  

-   **[RTC\_Timer32InterruptDisable Function](GUID-99CF65F7-8658-4FA9-8494-346D19C6E8E2.md)**  

-   **[RTC\_Timer32InterruptEnable Function](GUID-DBDF7577-2FC3-44F2-8297-7A6B332176DC.md)**  

-   **[RTC\_Timer32PeriodGet Function](GUID-6451AECF-AD51-4087-8656-1A6204AAB73F.md)**  

-   **[RTC\_Timer32Start Function](GUID-C27B513A-6502-4E54-98D8-3010023C3A12.md)**  

-   **[RTC\_Timer32Stop Function](GUID-DEC96435-9991-4E06-8032-AD13E238659C.md)**  

-   **[RTC\_TIMER32\_INT\_MASK Enum](GUID-13944889-7131-4A1E-832D-0077C2801784.md)**  

-   **[RTC\_TIMER32\_CALLBACK Typedef](GUID-DCFB70D2-3CCA-4F63-AFDB-6A50FE89DC76.md)**  

-   **[RTC\_PERIODIC\_INT\_MASK Enum](GUID-3EDB2E1A-F3F6-4B16-8ECD-B47CDD6F026F.md)**  

-   **[RTC\_FrequencyCorrect Function](GUID-FCFA1868-4EA5-43E7-A8B6-F60C27AB75C3.md)**  

-   **[RTC\_Timer16CallbackRegister Function](GUID-E546D39B-C44F-46F4-A472-63AFB12C912D.md)**  

-   **[RTC\_Timer16Compare0HasMatched Function](GUID-6A5280FF-B8D7-487C-992A-9414907D0A03.md)**  

-   **[RTC\_Timer16Compare0Set Function](GUID-EACB5BE8-75D3-4F0E-96E8-27CB7E64E7E9.md)**  

-   **[RTC\_Timer16Compare1HasMatched Function](GUID-F5D7B3B0-98BA-42A1-BD92-4BEDD1EB6D7E.md)**  

-   **[RTC\_Timer16Compare1Set Function](GUID-B2594109-7CF7-4F5B-8CC5-16D63A03F88A.md)**  

-   **[RTC\_Timer16CounterGet Function](GUID-D7F03789-A005-4D7F-BFEA-357D388925F8.md)**  

-   **[RTC\_Timer16CounterHasOverflowed Function](GUID-A9C7C6D4-CE8B-4901-A703-F721296477CD.md)**  

-   **[RTC\_Timer16CounterSet Function](GUID-CE0FCE8E-A7D2-4451-A6C8-D7760894A7DD.md)**  

-   **[RTC\_Timer16FrequencyGet Function](GUID-37BC3EBB-972F-4B53-8301-4E86ED28D69C.md)**  

-   **[RTC\_Timer16InterruptDisable Function](GUID-A11A1A5E-64F2-49E3-AAAA-5158C27D924A.md)**  

-   **[RTC\_Timer16InterruptEnable Function](GUID-59638687-7684-4667-AB21-58C7FD452F44.md)**  

-   **[RTC\_Timer16PeriodGet Function](GUID-42063F69-6C0C-4FA6-A9D6-DBF33CB1B5A1.md)**  

-   **[RTC\_Timer16PeriodSet Function](GUID-1DCC1CE6-5038-4D99-8705-D2EF32AB322A.md)**  

-   **[RTC\_Timer16Start Function](GUID-FBE47702-3B0D-4991-A9E6-17A9DDCB10F8.md)**  

-   **[RTC\_Timer16Stop Function](GUID-0DADCD3B-8654-484E-94F6-A1EC1E57B3DF.md)**  

-   **[RTC\_Timer16Compare2HasMatched Function](GUID-34E55562-449D-4ADE-8E5D-B1F303F14647.md)**  

-   **[RTC\_Timer16Compare2Set Function](GUID-541B5EB9-1C42-419A-9799-204ADFF10A11.md)**  

-   **[RTC\_Timer16Compare3HasMatched Function](GUID-AAD81AFA-038F-4682-B92D-4B5D225EAFF4.md)**  

-   **[RTC\_Timer16Compare3Set Function](GUID-29E6FAAA-6C56-4CB7-AD1C-FC2BC1B51D54.md)**  

-   **[RTC\_Timer16TimeStampGet Function](GUID-6A223B4A-DD78-48A3-965A-8B60AB8A462D.md)**  

-   **[RTC\_TIMER16\_CALLBACK Typedef](GUID-59F8538C-62ED-42F6-858F-5C9FCCEA9D60.md)**  

-   **[RTC\_TIMER16\_INT\_MASK Enum](GUID-277D91C4-EE27-4A36-BDAC-C58689F423DE.md)**  

-   **[RTC\_RTCCAlarmSet Function](GUID-6EBFC48E-400C-4E5A-A457-14E440E83E93.md)**  

-   **[RTC\_RTCCCallbackRegister Function](GUID-CEABC8D8-027E-47B2-ADB0-815B00F7937D.md)**  

-   **[RTC\_RTCCTimeGet Function](GUID-64AF9D09-94AF-422A-BA96-394DEB35B7F7.md)**  

-   **[RTC\_RTCCTimeSet Function](GUID-83B2D56A-5FD4-4DEB-8EE3-626FCC84CC65.md)**  

-   **[RTC\_BackupRegisterGet Function](GUID-ACDF44E8-881E-42C6-A7E8-5D01212FA801.md)**  

-   **[RTC\_BackupRegisterSet Function](GUID-FBFCAA94-BEB8-4D1E-98D1-B977C3EECE5F.md)**  

-   **[RTC\_RTCCTimeStampGet Function](GUID-E696BA13-F504-44F4-B65E-209374963001.md)**  

-   **[RTC\_TamperSourceGet Function](GUID-D0D05E1C-18DD-499C-A35E-AA3FFA2B7433.md)**  

-   **[RTC\_ALARM\_MASK Enum](GUID-F6934239-F544-44A1-A34A-2E28A4476A2D.md)**  

-   **[RTC\_CLOCK\_EVENT Enum](GUID-A4EE61CF-849B-4933-8C89-4F0A3ECF3A34.md)**  

-   **[RTC\_CALLBACK Typedef](GUID-47343662-2D4E-4C04-B763-F29C34A7AB7F.md)**  

-   **[BACKUP\_REGISTER Enum](GUID-70681C99-9AB9-425D-B9DC-B6F7DC6F4925.md)**  

-   **[RTC\_CLOCK\_INT\_MASK Enum](GUID-096CC418-1330-4AA4-A955-486C5EF2EE31.md)**  

-   **[TAMPER\_CHANNEL Enum](GUID-7E44A2CC-410B-4336-8CB2-7E7FA6FE13C5.md)**  


**Parent topic:**[PIC32CM JH00 JH01 Peripheral Libraries](GUID-05924E45-D6B3-4F33-A5EA-9B080FC421D8.md)

**Parent topic:**[PIC32CM LE00 LS00 LS60 Peripheral Libraries](GUID-F80F1B47-C3E4-4803-ACB6-D30AC5EB7B45.md)

**Parent topic:**[PIC32CM MC00 Peripheral Libraries](GUID-ADF45DC0-B32C-4D1F-9332-59EC0DF5097E.md)

**Parent topic:**[PIC32CX BZ2 WBZ45 Peripheral Libraries](GUID-3D519D00-FDEE-4A3E-9EF7-20F335E64CEE.md)

**Parent topic:**[PIC32CX BZ3 WBZ3 Peripheral Libraries](GUID-5752DD6D-6E5D-484D-B564-DA87788492F3.md)

**Parent topic:**[SAM C20 C21 Peripheral Libraries](GUID-49072E61-B7F2-4B32-952E-D6F5FB361AFB.md)

**Parent topic:**[SAM D51 E51 E53 E54 Peripheral Libraries](GUID-E33B93DD-6680-477E-AA96-966208DC9A50.md)

**Parent topic:**[SAM L1X Peripheral Libraries](GUID-D259BBBC-6BC2-4F69-849B-C06DF4DDD5F8.md)

**Parent topic:**[SAM L21 Peripheral Libraries](GUID-230EF724-3CDA-4F88-8E42-0EF4C1CA112D.md)

**Parent topic:**[SAM L22 Peripheral Libraries](GUID-C3997EBF-87A0-4DD9-BCB0-C8A58B62E44B.md)

