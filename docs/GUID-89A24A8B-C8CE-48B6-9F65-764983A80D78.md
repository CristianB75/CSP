# Analog Front-End Controller \(AFEC\)

-   12-bit Resolution up to 16-bit Resolution by Digital Averaging

-   Wide Range of Power Supply Operation

-   Selectable Single-ended or Differential Input Voltage

-   Selectable Single or Dual Sample-and-Hold Mode

-   Programmable Gain for Maximum Full-Scale Input Range 0â€“VDD

-   Programmable Offset Per Channel

-   Automatic Correction of Offset and Gain Errors

-   Integrated Multiplexers Offering Up to 12 Independent Analog Inputs

-   Individual Enable and Disable of Each Channel

-   Hardware or Software Trigger \(External trigger pin, Timer counter outputs \(corresponding TIOA trigger\), PWM event line\)

-   Drive of PWM Fault Input

-   DMA Support

-   Possibility of AFE Timings Configuration

-   Two Sleep Modes and Conversion Sequencer \(Automatic wakeup on trigger and back to sleep mode after conversions of all enabled channels, Possibility of customized channel sequence\)


**Using The Library**

**Interrupt mode:**

```c
#include <stddef.h>                     // Defines NULL
#include <stdbool.h>                    // Defines true
#include <stdlib.h>                     // Defines EXIT_FAILURE
#include "definitions.h"                // SYS function prototypes

/*****************************************************
 AFEC CH0 - PB01 - Connect to DACC output PB13
 AFEC CH5 - PC30 - connect to Vcc
 AFEC_CH6 - PC31 - Connect to GND
 *****************************************************/

#define AFEC_VREF               (3.3f)
#define DAC_COUNT_INCREMENT     (124U)  // Equivalent to 0.1V 
#define DAC_COUNT_MAX           (4095U)


volatile uint16_t adc_ch0_count, adc_ch5_count, adc_ch6_count;

float adc_ch0_voltage, adc_ch5_voltage, adc_ch6_voltage;

volatile bool result_ready;
/* Initial DAC count which is midpoint = 1.65V*/
uint16_t dac_count=0x800; 


void switch_handler( PIO_PIN pin, uintptr_t context )
{
    /* Write next data sample */
    dac_count = dac_count + DAC_COUNT_INCREMENT;
    
    if (dac_count > DAC_COUNT_MAX)
            dac_count=0;    
    
    DACC_DataWrite(DACC_CHANNEL_0, dac_count);
}

/* This function is called after conversion of last channel in the user sequence */
void AFEC_EventHandler(uint32_t status, uintptr_t context)
{
    /* Read the result of 3 channels*/
    adc_ch5_count = AFEC1_ChannelResultGet(CH5_VDD);
    adc_ch6_count = AFEC1_ChannelResultGet(CH6_GND);
    adc_ch0_count = AFEC1_ChannelResultGet(CH0_SINE_WAVE);
       
    result_ready = true;

}

// *****************************************************************************
// *****************************************************************************
// Section: Main Entry Point
// *****************************************************************************
// *****************************************************************************

int main ( void )
{
    /* Initialize all modules */
    SYS_Initialize ( NULL );
    
    PIO_PinInterruptCallbackRegister(SWITCH_PIN, &switch_handler, (uintptr_t) NULL );
    PIO_PinInterruptEnable(SWITCH_PIN);

    /* Register callback function for AFEC end of conversion interrupt*/
    AFEC1_CallbackRegister(AFEC_EventHandler, (uintptr_t)NULL);
    
    /* Write first data sample in DAC channel 0 and channel 1*/
    DACC_DataWrite(DACC_CHANNEL_0, dac_count);
    
    /* Start the timer to trigger ADC conversion every 50 ms*/
    TC1_CH0_CompareStart();

    printf("\n\r---------------------------------------------------------");
    printf("\n\r                    AFEC User Sequence Demo                 ");
    printf("\n\r---------------------------------------------------------\n\r");
    printf("CH0 Count  CH0 Voltage  CH5 Count  CH5 Voltage  CH6 Count  CH6 Voltage \n\r");           

    while ( true )
    {
        /* Check if result is ready to be transmitted to console */
        if (result_ready == true)
        {
            adc_ch5_voltage = (float)adc_ch5_count * AFEC_VREF/4095U;
            adc_ch6_voltage = (float)adc_ch6_count * AFEC_VREF/4095U;
            adc_ch0_voltage = (float)adc_ch0_count * AFEC_VREF/4095U;
            printf("0x%03x      %0.2f V       0x%03x      %0.2f V       0x%03x      %0.2f V \t\r", \
                    adc_ch0_count, adc_ch0_voltage, adc_ch5_count, adc_ch5_voltage, adc_ch6_count, adc_ch6_voltage);
                           
                
            result_ready = false;
        }
    }

    /* Execution should not come here during normal operation */

    return ( EXIT_FAILURE );
}
```

**Polling mode:**

```c
#include <stddef.h>                     // Defines NULL
#include <stdbool.h>                    // Defines true
#include <stdlib.h>                     // Defines EXIT_FAILURE
#include <stdio.h>
#include "definitions.h"                // SYS function prototypes

#define AFEC_VREF               (3.3f)
#define DAC_COUNT_INCREMENT     (124U)  // equivalent to 0.1V 
#define DAC_COUNT_MAX           (4095U)

uint16_t adc_count;
float input_voltage;
/* Initial value of dac count which is midpoint = 1.65 V*/
uint16_t dac_count = 0x800;   


void switch_handler( PIO_PIN pin, uintptr_t context )
{
    /* Write next data sample */
    dac_count = dac_count + DAC_COUNT_INCREMENT;
    
    if (dac_count > DAC_COUNT_MAX)
            dac_count=0;    
    
    DACC_DataWrite(DACC_CHANNEL_0, dac_count);
}

// *****************************************************************************
// *****************************************************************************
// Section: Main Entry Point
// *****************************************************************************
// *****************************************************************************

int main ( void )
{
    /* Initialize all modules */
    SYS_Initialize ( NULL );
    
    PIO_PinInterruptCallbackRegister(SWITCH_PIN, &switch_handler, (uintptr_t) NULL );
    PIO_PinInterruptEnable(SWITCH_PIN);
    
    printf("\n\r---------------------------------------------------------");
    printf("\n\r                    AFEC Demo                 ");
    printf("\n\r---------------------------------------------------------\n\r");
    printf("Press switch to change the DAC output. \r\n");
    
    SYSTICK_TimerStart();

    DACC_DataWrite(DACC_CHANNEL_0, dac_count);
        
    while (1)
    {
        /* Start ADC conversion */
        AFEC1_ConversionStart();

        /* Wait till ADC conversion result is available */
        while(!AFEC1_ChannelResultIsReady(AFEC_CH0))
        {

        };

        /* Read the ADC result */
        adc_count = AFEC1_ChannelResultGet(AFEC_CH0);
        input_voltage = (float)adc_count * AFEC_VREF / 4095U;

        printf("ADC Count = 0x%03x, ADC Input Voltage = %0.2f V \r",adc_count, input_voltage);    
        
        SYSTICK_DelayMs(500);
    }
    
    /* Execution should not come here during normal operation */

    return ( EXIT_FAILURE );
}
```

**Library Interface**

Analog Front-End Controller peripheral library provides the following interfaces:

**Functions**

|Name|Description|
|----|-----------|
|AFECx\_Initialize|Initializes given instance of AFEC peripheral|
|AFECx\_ChannelsEnable|Enables the ADC channels|
|AFECx\_ChannelsDisable|Disables the ADC channels|
|AFECx\_ChannelsInterruptEnable|Enables the ADC interrupt sources|
|AFECx\_ChannelsInterruptDisable|Disables the ADC interrupt sources|
|AFECx\_ConversionStart|Starts the ADC conversion of all the enabled channels with the software trigger|
|AFECx\_ChannelResultIsReady|Returns the status of the channel conversion|
|AFECx\_ChannelResultGet|Reads the conversion result of the channel|
|AFECx\_ConversionSequenceSet|Sets the user sequence of the channel conversion|
|AFECx\_ChannelGainSet|Writes the gain of the channel|
|AFECx\_ChannelOffsetSet|Writes the channel offset|
|AFECx\_CallbackRegister|Registers the function to be called from interrupt|

**Data types and constants**

|Name|Type|Description|
|----|----|-----------|
|AFEC\_CHANNEL\_NUM|Enum|Identifies AFEC channel number|
|AFEC\_INTERRUPT\_MASK|Enum|Identifies channel interrupt sources mask|
|AFEC\_CHANNEL\_MASK|Enum|Identifies AFEC channel mask|
|AFEC\_CHANNEL\_GAIN|Enum|Identifies programmable gain setting|
|AFEC\_CALLBACK|Typedef|Defines the function pointer data type and function signature for the afec peripheral callback function|
|AFEC\_CALLBACK\_OBJECT|Struct|AFEC Callback structure|

-   **[AFECx\_Initialize Function](GUID-8D758FA1-3FF1-464A-B642-41AE79EED84F.md)**  

-   **[AFECx\_ChannelsEnable Function](GUID-720AA2E5-21B1-4103-8782-A80EA2AD4E92.md)**  

-   **[AFECx\_ChannelsDisable Function](GUID-0B03AF1F-D385-4D17-B20D-14B794855BEE.md)**  

-   **[AFECx\_ChannelsInterruptEnable Function](GUID-4113E7AB-8DCB-4A2D-B5CD-262ACF365D5A.md)**  

-   **[AFECx\_ChannelsInterruptDisable Function](GUID-5740036A-0248-43CF-94F3-9228BB86DB68.md)**  

-   **[AFECx\_ConversionStart Function](GUID-3FEB3476-A00F-4033-94FC-A3E03BEC4910.md)**  

-   **[AFECx\_ChannelResultIsReady Function](GUID-D2DEFF3D-DB2D-4127-A147-57158D5CF0EF.md)**  

-   **[AFECx\_ChannelResultGet Function](GUID-49BE1670-DCC5-4788-B599-B2050C702665.md)**  

-   **[AFECx\_ConversionSequenceSet Function](GUID-C00602AA-2A47-43E5-831A-D998B03F21FE.md)**  

-   **[AFECx\_ChannelGainSet Function](GUID-FC1D220A-5720-4653-BFBB-16550F435CD9.md)**  

-   **[AFECx\_ChannelOffsetSet Function](GUID-E4F5615E-4A35-42EE-99C9-48439125F591.md)**  

-   **[AFECx\_CallbackRegister Function](GUID-7FD7D9CC-3164-49CA-BD0C-A7B68795F58F.md)**  

-   **[AFEC\_CHANNEL\_NUM Enum](GUID-4A6CED8C-9AE4-4236-88D8-8BB4E1150BF6.md)**  

-   **[AFEC\_INTERRUPT\_MASK Enum](GUID-AE838876-5D84-463F-9450-F625FE74C8A1.md)**  

-   **[AFEC\_CHANNEL\_MASK Enum](GUID-412B6865-E78E-46BD-9B78-4B6759A82EC7.md)**  

-   **[AFEC\_CHANNEL\_GAIN Enum](GUID-45FC1E88-A9E9-449F-B068-57580447CFA8.md)**  

-   **[AFEC\_CALLBACK Typedef](GUID-B87B3321-CFAB-41E7-95E4-A529DCA463ED.md)**  

-   **[AFEC\_CALLBACK\_OBJECT Struct](GUID-A9CF86F4-93E2-4607-87BA-695343383DE1.md)**  


**Parent topic:**[SAM E70 S70 V70 V71 Peripheral Libraries](GUID-6E45C146-6F6D-452A-A2E2-228C3CC905D7.md)

