# SERCOMx\_I2C\_WriteRead\_HighSpeed Function

**Parent topic:**[Serial Communication Interface \(SERCOM\)](GUID-76AE7205-E3EF-4EE6-AC28-5153E3565982.md)

## C

```c
/* x = SERCOM instance number */

/* I2C master mode */

bool SERCOMx_I2C_WriteRead_HighSpeed(uint16_t address, uint8_t *wdata, uint32_t wlength, uint8_t *rdata, uint32_t rlength) 
```

## Summary

Write and Read data from I2C slave in high speed mode

## Description

This function writes data from the wdata to the bus and then reads data from the slave and stores the received in the rdata. The I2C Master generates a Start condition, and transmits the master code in full speed mode. After receiving a NAK, the transfer takes place in high speed mode. The function generates a Repeated Start condition on the bus and will then send wlength number of bytes contained in wdata. The function will then insert a repeated start condition and proceeds to read rlength number of bytes from the slave. The received bytes are stored in rdata buffer. A Stop condition is generated after the last byte has been received. If the slave NAKs the request or a bus error was encountered on the bus, the transfer is terminated. The application can call the SERCOMx\_I2C\_TransferStatusGet\(\) function and the SERCOMx\_I2C\_ErrorGet\(\) function to know the cause of the error. The function is non-blocking. It initiates bus activity and returns immediately. The transfer is then completed in the peripheral interrupt. A transfer request cannot be placed when another transfer is in progress. Calling this function when another function is already in progress will cause the function to return false. The library will call the registered callback function when the transfer has terminated.

## Precondition

SERCOMx\_I2C\_Initialize must have been called for the associated SERCOM I2C instance

## Parameters

|Param|Description|
|-----|-----------|
|address|7-bit / 10-bit slave address|
|wdata|pointer to write data buffer|
|wlength|write data length in bytes|
|rdata|pointer to read data buffer|
|rlength|read data length in bytes|

## Returns

*true* - The request was placed successfully and the bus activity was initiated

*false* - The request fails, if there was already a transfer in progress when this function was called

## Example

```c
uint8_t myTxData [NUM_BYTES] = {'1', '0', ' ', 'B', 'Y', 'T', 'E', 'S'};
uint8_t myRxData [NUM_BYTES] = {0};
    
    if(!SERCOM0_I2C_WriteRead_HighSpeed( SLAVE_ADDR, &myTxData[0], NUM_BYTES, myRxData, NUM_BYTES ))
    {
        // error handling
    }
    
```

## Remarks

Calling this function is not the same as calling the SERCOMx\_I2C\_Write\(\) function and then calling the SERCOMx\_I2C\_Read\(\) function. The SERCOMx\_I2C\_WriteRead function will insert a Repeated Start condition between the Write and the Read stages. The SERCOMx\_I2C\_Write\(\) and the SERCOMx\_I2C\_Read\(\) function insert a stop condition after the write and the read has completed.

