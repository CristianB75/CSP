# SERCOMx\_I2C\_TransferDirGet Function

**Parent topic:**[Serial Communication Interface \(SERCOM\)](GUID-76AE7205-E3EF-4EE6-AC28-5153E3565982.md)

## C

```c
/* x = SERCOM instance number */

/* I2C slave mode */

SERCOM_I2C_SLAVE_TRANSFER_DIR SERCOMx_I2C_TransferDirGet(void)	
```

## Summary

Returns the I2C transfer direction

## Description

This function returns the I2C transfer direction

## Precondition

SERCOMx\_I2C\_Initialize must have been called for the associated SERCOM I2C instance

## Parameters

None.

## Returns

*SERCOM\_I2C\_SLAVE\_TRANSFER\_DIR\_WRITE* - I2C master is writing data to I2C slave

*SERCOM\_I2C\_SLAVE\_TRANSFER\_DIR\_READ* - I2C master is reading data from I2C slave

## Example

The below code snippet shows the use of the SERCOMx\_I2C\_TransferDirGet\(\) API when<br />SERCOM I2C slave PLIB is used in polled mode \(interrupt is disabled\).

```c
static bool isFirstByteSent;
static bool transferDir;
SERCOM_I2C_SLAVE_INTFLAG intFlags = SERCOM0_I2C_InterruptFlagsGet();

if (intFlags & SERCOM_I2C_SLAVE_INTFLAG_AMATCH)
{
    isFirstByteSent = false;
    
    // Read and save the transfer direction in a global variable.
    transferDir = SERCOM0_I2C_TransferDirGet();
    
    // Send ACK succeeded by reception of next byte
    SERCOM0_I2C_SendCommand(SERCOM_I2C_SLAVE_COMMAND_SEND_ACK);
}
else if (intFlags & SERCOM_I2C_SLAVE_INTFLAG_DRDY)
{
    if (transferDir == SERCOM_I2C_SLAVE_TRANSFER_DIR_WRITE)
    {
        // I2C master is writing data to I2C slave. Read the received byte.
        rxByte = SERCOM0_I2C_ReadByte();
        
        // Execute acknowledge action succeeded by reception of next byte
        SERCOM0_I2C_SendCommand(SERCOM_I2C_SLAVE_COMMAND_SEND_ACK);
    }
    else
    {
        // I2C master is reading data from I2C slave. Check if the previous data
        // is acknowledged by the I2C master.
        
        if (isFirstByteSent == false)
        {
            SERCOM0_I2C_WriteByte(txData);
            isFirstByteSent = true;
        }
        else
        {
            if (SERCOM0_I2C_LastByteAckStatusGet() == SERCOM_I2C_SLAVE_ACK_STATUS_RECEIVED_ACK)
            {
                // Last byte was acknowledged by the I2C master; send another byte.
                
                SERCOM0_I2C_WriteByte(txData);
                
                //Execute a byte read operation followed by ACK/NACK reception
                SERCOM0_I2C_SendCommand(SERCOM_I2C_SLAVE_COMMAND_RECEIVE_ACK_NAK);
            }
            else
            {
                // Last byte was NAK'd by the I2C master; wait for start condition.
                
                //Wait for any start (S/Sr) condition
                SERCOM0_I2C_SendCommand(SERCOM_I2C_SLAVE_COMMAND_WAIT_FOR_START);
            }
        }
    }
}

```

## Remarks

None.

