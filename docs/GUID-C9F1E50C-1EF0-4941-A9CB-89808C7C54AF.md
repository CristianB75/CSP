# Controller Area Network \(MCAN\)

The Controller Area Network \(MCAN\) performs communication according to<br />ISO 11898-1:2015 and to Bosch CAN-FD specification. Additional<br />transceiver hardware is required for connection to the physical layer.

All functions concerning the handling of messages are implemented by<br />the Rx Handler and the Tx Handler. The Rx Handler manages message<br />acceptance filtering, the transfer of received messages from the CAN<br />core to the Message RAM, as well as providing receive message status<br />information. The Tx Handler is responsible for the transfer of transmit<br />messages from the Message RAM to the CAN core, as well as providing<br />transmit status information. Acceptance filtering is implemented by a<br />combination of up to 128 filter elements, where each element can be<br />configured as a range, as a bit mask, or as a dedicated ID filter.

**Using The Library**

The MCAN library supports the Normal and CAN-FD modes. The MCAN Normal<br />or CAN-FD mode can transfer message in a polling or an interrupt mode.

**MCAN Message RAM Configuration**

Allocate MCAN Message RAM configuration in contiguous non-cacheable<br />buffer in the application.

For example in SAME70, uint8\_t<br />Mcan1MessageRAM **attribute**\(\(aligned<br />\(32\)\)\)**attribute**\(\(space\(data\), section \(".ram\_nocache"\)\)\);

For example in SAMA5D2, uint8\_t<br />Mcan0MessageRAM **attribute**\(\(aligned<br />\(32\)\)\) **attribute**\(\(**section**\(".region\_nocache"\)\)\)

If cache is enabled then non-cacheable section "ram\_nocache" or<br />"region\_nocache" should be added in linker script \(if non-cacheable<br />\\section is not present in linker script\).

**MCAN polling mode:**

```c
#include <stddef.h>                     // Defines NULL
#include <stdbool.h>                    // Defines true
#include <stdlib.h>                     // Defines EXIT_FAILURE
#include "definitions.h"                // SYS function prototypes

uint8_t Mcan1MessageRAM[MCAN1_MESSAGE_RAM_CONFIG_SIZE] __attribute__((aligned (32)))__attribute__((space(data), section (".ram_nocache")));
        
/* Standard identifier id[28:18]*/
#define WRITE_ID(id) (id << 18)
#define READ_ID(id)  (id >> 18)

static uint32_t status = 0;
static uint8_t loop_count = 0;
static uint8_t user_input = 0;

static uint8_t txFiFo[MCAN1_TX_FIFO_BUFFER_SIZE];
static uint8_t rxFiFo0[MCAN1_RX_FIFO0_SIZE];
static uint8_t rxFiFo1[MCAN1_RX_FIFO1_SIZE];
static uint8_t rxBuffer[MCAN1_RX_BUFFER_SIZE];

// *****************************************************************************
// *****************************************************************************
// Section: Local functions
// *****************************************************************************
// *****************************************************************************

/* Message Length to Data length code */
static uint8_t MCANLengthToDlcGet(uint8_t length)
{
    uint8_t dlc = 0;

    if (length <= 8U)
    {
        dlc = length;
    }
    else if (length <= 12U)
    {
        dlc = 0x9U;
    }
    else if (length <= 16U)
    {
        dlc = 0xAU;
    }
    else if (length <= 20U)
    {
        dlc = 0xBU;
    }
    else if (length <= 24U)
    {
        dlc = 0xCU;
    }
    else if (length <= 32U)
    {
        dlc = 0xDU;
    }
    else if (length <= 48U)
    {
        dlc = 0xEU;
    }
    else
    {
        dlc = 0xFU;
    }
    return dlc;
}

/* Data length code to Message Length */
static uint8_t MCANDlcToLengthGet(uint8_t dlc)
{
    uint8_t msgLength[] = {0U, 1U, 2U, 3U, 4U, 5U, 6U, 7U, 8U, 12U, 16U, 20U, 24U, 32U, 48U, 64U};
    return msgLength[dlc];
}

/* Menu */
static void display_menu(void)
{
	printf("Menu :\r\n"
	       "  -- Select the action:\r\n"
	       "  0: Send FD standard message with ID: 0x45A and 64 byte data 0 to 63. \r\n"
	       "  1: Send FD standard message with ID: 0x469 and 64 byte data 128 to 191. \r\n"
	       "  2: Send FD extended message with ID: 0x100000A5 and 64 byte data 0 to 63. \r\n"
	       "  3: Send FD extended message with ID: 0x10000096 and 64 byte data 128 to 191. \r\n"
	       "  4: Send normal standard message with ID: 0x469 and 8 byte data 0 to 7. \r\n"
	       "  m: Display menu \r\n\r\n");
}

/* Print Rx Message */
static void print_message(uint8_t numberOfMessage, MCAN_RX_BUFFER *rxBuf, uint8_t rxBufLen, uint8_t rxFifoBuf)
{
    uint8_t length = 0;
    uint8_t msgLength = 0;
    uint32_t id = 0;

    if (rxFifoBuf == 0)
        printf(" Rx FIFO0 :");
    else if (rxFifoBuf == 1)
        printf(" Rx FIFO1 :");
    else if (rxFifoBuf == 2)
        printf(" Rx Buffer :");

    for (uint8_t count = 0; count < numberOfMessage; count++)
    {
        /* Print message to Console */
        printf(" New Message Received\r\n");
        id = rxBuf->xtd ? rxBuf->id : READ_ID(rxBuf->id);
        msgLength = MCANDlcToLengthGet(rxBuf->dlc);
        length = msgLength;
        printf(" Message - ID : 0x%x Length : 0x%x ", (unsigned int)id, (unsigned int)msgLength);
        printf("Message : ");
        while(length)
        {
            printf("0x%x ", rxBuf->data[msgLength - length--]);
        }
        printf("\r\n");
        rxBuf += rxBufLen;
    }
}

// *****************************************************************************
// *****************************************************************************
// Section: Main Entry Point
// *****************************************************************************
// *****************************************************************************

int main ( void )
{
    MCAN_TX_BUFFER *txBuffer = NULL;
    uint8_t        bufferNumber = 0;
    uint8_t        numberOfMessage = 0;

    /* Initialize all modules */
    SYS_Initialize ( NULL );

    printf(" ------------------------------ \r\n");
    printf("            MCAN FD Demo          \r\n");
    printf(" ------------------------------ \r\n");
    
    /* Set Message RAM Configuration */
    MCAN1_MessageRAMConfigSet(Mcan1MessageRAM);

    display_menu();
     
    while ( true )
    {
        /* Rx Buffers */
        if (MCAN1_InterruptGet(MCAN_INTERRUPT_DRX_MASK))
        {    
            MCAN1_InterruptClear(MCAN_INTERRUPT_DRX_MASK);

            /* Check MCAN Status */
            status = MCAN1_ErrorGet();

            if (((status & MCAN_PSR_LEC_Msk) == MCAN_ERROR_NONE) || ((status & MCAN_PSR_LEC_Msk) == MCAN_ERROR_LEC_NO_CHANGE))
            {
                if (MCAN1_RxBufferNumberGet(&bufferNumber))
                {
                    memset(rxBuffer, 0x00, MCAN1_RX_BUFFER_ELEMENT_SIZE);
                    if (MCAN1_MessageReceive(bufferNumber, (MCAN_RX_BUFFER *)rxBuffer) == true)
                    {
                        print_message(1, (MCAN_RX_BUFFER *)rxBuffer, MCAN1_RX_BUFFER_ELEMENT_SIZE, 2);
                    }
                    else
                    {
                        printf(" Error in received message\r\n");
                    }
                }
            }
            else
            {
                printf(" Error in received message\r\n");
            }
        }

        /* Rx FIFO0 */
        if (MCAN1_InterruptGet(MCAN_INTERRUPT_RF0N_MASK))
        {    
            MCAN1_InterruptClear(MCAN_INTERRUPT_RF0N_MASK);

            /* Check MCAN Status */
            status = MCAN1_ErrorGet();

            if (((status & MCAN_PSR_LEC_Msk) == MCAN_ERROR_NONE) || ((status & MCAN_PSR_LEC_Msk) == MCAN_ERROR_LEC_NO_CHANGE))
            {
                numberOfMessage = MCAN1_RxFifoFillLevelGet(MCAN_RX_FIFO_0);
                if (numberOfMessage != 0)
                {
                    memset(rxFiFo0, 0x00, (numberOfMessage * MCAN1_RX_FIFO0_ELEMENT_SIZE));
                    if (MCAN1_MessageReceiveFifo(MCAN_RX_FIFO_0, numberOfMessage, (MCAN_RX_BUFFER *)rxFiFo0) == true)
                    {
                        print_message(numberOfMessage, (MCAN_RX_BUFFER *)rxFiFo0, MCAN1_RX_FIFO0_ELEMENT_SIZE, 0);
                    }
                    else
                    {
                        printf(" Error in received message\r\n");
                    }
                }
            }
            else
            {
                printf(" Error in received message\r\n");
            }
        }

        /* Rx FIFO1 */
        if (MCAN1_InterruptGet(MCAN_INTERRUPT_RF1N_MASK))
        {    
            MCAN1_InterruptClear(MCAN_INTERRUPT_RF1N_MASK);

            /* Check MCAN Status */
            status = MCAN1_ErrorGet();

            if (((status & MCAN_PSR_LEC_Msk) == MCAN_ERROR_NONE) || ((status & MCAN_PSR_LEC_Msk) == MCAN_ERROR_LEC_NO_CHANGE))
            {
                numberOfMessage = MCAN1_RxFifoFillLevelGet(MCAN_RX_FIFO_1);
                if (numberOfMessage != 0)
                {
                    memset(rxFiFo1, 0x00, (numberOfMessage * MCAN1_RX_FIFO1_ELEMENT_SIZE));
                    if (MCAN1_MessageReceiveFifo(MCAN_RX_FIFO_1, numberOfMessage, (MCAN_RX_BUFFER *)rxFiFo1) == true)
                    {
                        print_message(numberOfMessage, (MCAN_RX_BUFFER *)rxFiFo1, MCAN1_RX_FIFO1_ELEMENT_SIZE, 1);
                    }
                    else
                    {
                        printf(" Error in received message\r\n");
                    }
                }
            }
            else
            {
                printf(" Error in received message\r\n");
            }
        }

        /* User input */
        if (USART1_ReceiverIsReady() == false)
        {
            continue;
        }
        user_input = (uint8_t)USART1_ReadByte();

        switch (user_input)
        {
            case '0':
                memset(txFiFo, 0x00, MCAN1_TX_FIFO_BUFFER_ELEMENT_SIZE);
                txBuffer = (MCAN_TX_BUFFER *)txFiFo;
                txBuffer->id = WRITE_ID(0x45A);
                txBuffer->dlc = MCANLengthToDlcGet(64);
                txBuffer->fdf = 1;
                txBuffer->brs = 1;
                for (loop_count = 0; loop_count < 64; loop_count++){
                    txBuffer->data[loop_count] = loop_count;
                }                
                printf("  0: Send FD standard message with ID: 0x45A and 64 byte data 0 to 63.\r\n");
                if (MCAN1_MessageTransmitFifo(1, txBuffer) == true)
                {    
                    printf(" Success \r\n");
                }
                else
                {
                    printf(" Failed \r\n");
                }             
                break;  
            case '1':
                memset(txFiFo, 0x00, MCAN1_TX_FIFO_BUFFER_ELEMENT_SIZE);
                txBuffer = (MCAN_TX_BUFFER *)txFiFo;
                txBuffer->id = WRITE_ID(0x469);
                txBuffer->dlc = MCANLengthToDlcGet(64);
                txBuffer->fdf = 1;
                txBuffer->brs = 1;
                for (loop_count = 128; loop_count < 192; loop_count++){
                    txBuffer->data[loop_count - 128] = loop_count;
                }                
                printf("  1: Send FD standard message with ID: 0x469 and 64 byte data 128 to 191.\r\n");
                if (MCAN1_MessageTransmitFifo(1, txBuffer) == true)
                {    
                    printf(" Success \r\n");
                }
                else
                {
                    printf(" Failed \r\n");
                }    
                break;
            case '2': 
                memset(txFiFo, 0x00, MCAN1_TX_FIFO_BUFFER_ELEMENT_SIZE);
                txBuffer = (MCAN_TX_BUFFER *)txFiFo;
                txBuffer->id = 0x100000A5;
                txBuffer->dlc = MCANLengthToDlcGet(64);
                txBuffer->xtd = 1;
                txBuffer->fdf = 1;
                txBuffer->brs = 1;
                for (loop_count = 0; loop_count < 64; loop_count++){
                    txBuffer->data[loop_count] = loop_count;
                }
                printf("  2: Send FD extended message with ID: 0x100000A5 and 64 byte data 0 to 63.\r\n");
                if (MCAN1_MessageTransmitFifo(1, txBuffer) == true)
                {    
                    printf(" Success \r\n");
                }
                else
                {
                    printf(" Failed \r\n");
                }             
                break;
            case '3':
                memset(txFiFo, 0x00, MCAN1_TX_FIFO_BUFFER_ELEMENT_SIZE);
                txBuffer = (MCAN_TX_BUFFER *)txFiFo;
                txBuffer->id = 0x10000096;
                txBuffer->dlc = MCANLengthToDlcGet(64);
                txBuffer->xtd = 1;
                txBuffer->fdf = 1;
                txBuffer->brs = 1;
                for (loop_count = 128; loop_count < 192; loop_count++){
                    txBuffer->data[loop_count - 128] = loop_count;
                }
                printf("  3: Send FD extended message with ID: 0x10000096 and 64 byte data 128 to 191.\r\n");
                if (MCAN1_MessageTransmitFifo(1, txBuffer) == true)
                {    
                    printf(" Success \r\n");
                }
                else
                {
                    printf(" Failed \r\n");
                }             
                break;
            
            case '4':
                memset(txFiFo, 0x00, MCAN1_TX_FIFO_BUFFER_ELEMENT_SIZE);
                txBuffer = (MCAN_TX_BUFFER *)txFiFo;
                txBuffer->id = WRITE_ID(0x469);
                txBuffer->dlc = 8;
                for (loop_count = 0; loop_count < 8; loop_count++){
                    txBuffer->data[loop_count] = loop_count;
                }                
                printf("  4: Send normal standard message with ID: 0x469 and 8 byte data 0 to 7.\r\n");
                if (MCAN1_MessageTransmitFifo(1, txBuffer) == true)
                {    
                    printf(" Success \r\n");
                }
                else
                {
                    printf(" Failed \r\n");
                }             
                break;                 

            case 'm':
            case 'M':
                display_menu();
                break;
                
            default:
                printf(" Invalid Input \r\n");
                break;
        }  
    }

    /* Execution should not come here during normal operation */

    return ( EXIT_FAILURE );
}
```

**MCAN interrupt mode:**

```c
#include <stddef.h>                     // Defines NULL
#include <stdbool.h>                    // Defines true
#include <stdlib.h>                     // Defines EXIT_FAILURE
#include "definitions.h"                // SYS function prototypes

uint8_t Mcan1MessageRAM[MCAN1_MESSAGE_RAM_CONFIG_SIZE] __attribute__((aligned (32)))__attribute__((space(data), section (".ram_nocache")));

/* Standard identifier id[28:18]*/
#define WRITE_ID(id) (id << 18)
#define READ_ID(id)  (id >> 18)

/* Application's state machine enum */
typedef enum
{
    APP_STATE_MCAN_RECEIVE,
    APP_STATE_MCAN_TRANSMIT,
    APP_STATE_MCAN_IDLE,
    APP_STATE_MCAN_XFER_SUCCESSFUL,
    APP_STATE_MCAN_XFER_ERROR,
    APP_STATE_MCAN_USER_INPUT
} APP_STATES;

/* Variable to save Tx/Rx transfer status and context */
static uint32_t status = 0;
static uint32_t xferContext = 0;
/* Variable to save Tx/Rx message */
static uint8_t loop_count = 0;
static uint8_t user_input = 0;
/* Variable to save application state */
volatile static APP_STATES state = APP_STATE_MCAN_USER_INPUT;

static uint8_t txFiFo[MCAN1_TX_FIFO_BUFFER_SIZE];
static uint8_t rxFiFo0[MCAN1_RX_FIFO0_SIZE];
static uint8_t rxFiFo1[MCAN1_RX_FIFO1_SIZE];
static uint8_t rxBuffer[MCAN1_RX_BUFFER_SIZE];

// *****************************************************************************
// *****************************************************************************
// Section: Local functions
// *****************************************************************************
// *****************************************************************************

/* Message Length to Data length code */
static uint8_t MCANLengthToDlcGet(uint8_t length)
{
    uint8_t dlc = 0;

    if (length <= 8U)
    {
        dlc = length;
    }
    else if (length <= 12U)
    {
        dlc = 0x9U;
    }
    else if (length <= 16U)
    {
        dlc = 0xAU;
    }
    else if (length <= 20U)
    {
        dlc = 0xBU;
    }
    else if (length <= 24U)
    {
        dlc = 0xCU;
    }
    else if (length <= 32U)
    {
        dlc = 0xDU;
    }
    else if (length <= 48U)
    {
        dlc = 0xEU;
    }
    else
    {
        dlc = 0xFU;
    }
    return dlc;
}

/* Data length code to Message Length */
static uint8_t MCANDlcToLengthGet(uint8_t dlc)
{
    uint8_t msgLength[] = {0U, 1U, 2U, 3U, 4U, 5U, 6U, 7U, 8U, 12U, 16U, 20U, 24U, 32U, 48U, 64U};
    return msgLength[dlc];
}

/* Menu */
static void display_menu(void)
{
	printf("Menu :\r\n"
	       "  -- Select the action:\r\n"
	       "  0: Send FD standard message with ID: 0x45A and 64 byte data 0 to 63. \r\n"
	       "  1: Send FD standard message with ID: 0x469 and 64 byte data 128 to 191. \r\n"
	       "  2: Send FD extended message with ID: 0x100000A5 and 64 byte data 0 to 63. \r\n"
	       "  3: Send FD extended message with ID: 0x10000096 and 64 byte data 128 to 191. \r\n"
	       "  4: Send normal standard message with ID: 0x469 and 8 byte data 0 to 7. \r\n"
	       "  m: Display menu \r\n\r\n");
}

/* Print Rx Message */
static void print_message(uint8_t numberOfMessage, MCAN_RX_BUFFER *rxBuf, uint8_t rxBufLen, uint8_t rxFifoBuf)
{
    uint8_t length = 0;
    uint8_t msgLength = 0;
    uint32_t id = 0;

    if (rxFifoBuf == 0)
        printf(" Rx FIFO0 :");
    else if (rxFifoBuf == 1)
        printf(" Rx FIFO1 :");
    else if (rxFifoBuf == 2)
        printf(" Rx Buffer :");

    for (uint8_t count = 0; count < numberOfMessage; count++)
    {
        /* Print message to Console */
        printf(" New Message Received\r\n");
        id = rxBuf->xtd ? rxBuf->id : READ_ID(rxBuf->id);
        msgLength = MCANDlcToLengthGet(rxBuf->dlc);
        length = msgLength;
        printf(" Message - Timestamp : 0x%x ID : 0x%x Length : 0x%x ", (unsigned int)rxBuf->rxts, (unsigned int)id, (unsigned int)msgLength);
        printf("Message : ");
        while(length)
        {
            printf("0x%x ", rxBuf->data[msgLength - length--]);
        }
        printf("\r\n");
        rxBuf += rxBufLen;
    }
}

/* This function will be called by MCAN PLIB when transfer is completed from Tx FIFO */
void APP_MCAN_TxFifoCallback(uintptr_t context)
{
    xferContext = context;

    /* Check MCAN Status */
    status = MCAN1_ErrorGet();

    if (((status & MCAN_PSR_LEC_Msk) == MCAN_ERROR_NONE) || ((status & MCAN_PSR_LEC_Msk) == MCAN_ERROR_LEC_NO_CHANGE))
    {
        switch ((APP_STATES)context)
        {
            case APP_STATE_MCAN_TRANSMIT:
            {
                state = APP_STATE_MCAN_XFER_SUCCESSFUL;
                break;
            }
            default:
                break;
        }
    }
    else
    {
        state = APP_STATE_MCAN_XFER_ERROR;
    }
}

/* This function will be called by MCAN PLIB when Message received in Rx Buffer */
void APP_MCAN_RxBufferCallback(uint8_t bufferNumber, uintptr_t context)
{
    xferContext = context;

    /* Check MCAN Status */
    status = MCAN1_ErrorGet();

    if (((status & MCAN_PSR_LEC_Msk) == MCAN_ERROR_NONE) || ((status & MCAN_PSR_LEC_Msk) == MCAN_ERROR_LEC_NO_CHANGE))
    {
        switch ((APP_STATES)context)
        {
            case APP_STATE_MCAN_RECEIVE:
            {
                memset(rxBuffer, 0x00, MCAN1_RX_BUFFER_ELEMENT_SIZE);
                if (MCAN1_MessageReceive(bufferNumber, (MCAN_RX_BUFFER *)rxBuffer) == true)
                {
                    print_message(1, (MCAN_RX_BUFFER *)rxBuffer, MCAN1_RX_BUFFER_ELEMENT_SIZE, 2);
                    state = APP_STATE_MCAN_XFER_SUCCESSFUL;
                }
                else
                {
                    state = APP_STATE_MCAN_XFER_ERROR;
                }
                break;
            }
            default:
                break;
        }
    }
    else
    {
        state = APP_STATE_MCAN_XFER_ERROR;
    }
}

/* This function will be called by MCAN PLIB when Message received in Rx FIFO0 */
void APP_MCAN_RxFifo0Callback(uint8_t numberOfMessage, uintptr_t context)
{
    xferContext = context;

    /* Check MCAN Status */
    status = MCAN1_ErrorGet();

    if (((status & MCAN_PSR_LEC_Msk) == MCAN_ERROR_NONE) || ((status & MCAN_PSR_LEC_Msk) == MCAN_ERROR_LEC_NO_CHANGE))
    {
        switch ((APP_STATES)context)
        {
            case APP_STATE_MCAN_RECEIVE:
            {
                memset(rxFiFo0, 0x00, (numberOfMessage * MCAN1_RX_FIFO0_ELEMENT_SIZE));
                if (MCAN1_MessageReceiveFifo(MCAN_RX_FIFO_0, numberOfMessage, (MCAN_RX_BUFFER *)rxFiFo0) == true)
                {
                    print_message(numberOfMessage, (MCAN_RX_BUFFER *)rxFiFo0, MCAN1_RX_FIFO0_ELEMENT_SIZE, 0);
                    state = APP_STATE_MCAN_XFER_SUCCESSFUL;
                }
                else
                {
                    state = APP_STATE_MCAN_XFER_ERROR;
                }
                break;
            }
            default:
                break;
        }
    }
    else
    {
        state = APP_STATE_MCAN_XFER_ERROR;
    }
}

/* This function will be called by MCAN PLIB when Message received in Rx FIFO1 */
void APP_MCAN_RxFifo1Callback(uint8_t numberOfMessage, uintptr_t context)
{
    xferContext = context;

    /* Check MCAN Status */
    status = MCAN1_ErrorGet();

    if (((status & MCAN_PSR_LEC_Msk) == MCAN_ERROR_NONE) || ((status & MCAN_PSR_LEC_Msk) == MCAN_ERROR_LEC_NO_CHANGE))
    {
        switch ((APP_STATES)context)
        {
            case APP_STATE_MCAN_RECEIVE:
            {
                memset(rxFiFo1, 0x00, (numberOfMessage * MCAN1_RX_FIFO1_ELEMENT_SIZE));
                if (MCAN1_MessageReceiveFifo(MCAN_RX_FIFO_1, numberOfMessage, (MCAN_RX_BUFFER *)rxFiFo1) == true)
                {
                    print_message(numberOfMessage, (MCAN_RX_BUFFER *)rxFiFo1, MCAN1_RX_FIFO1_ELEMENT_SIZE, 1);
                    state = APP_STATE_MCAN_XFER_SUCCESSFUL;
                }
                else
                {
                    state = APP_STATE_MCAN_XFER_ERROR;
                }
                break;
            }
            default:
                break;
        }
    }
    else
    {
        state = APP_STATE_MCAN_XFER_ERROR;
    }
}

// *****************************************************************************
// *****************************************************************************
// Section: Main Entry Point
// *****************************************************************************
// *****************************************************************************

int main ( void )
{
    MCAN_TX_BUFFER *txBuffer = NULL;

    /* Initialize all modules */
    SYS_Initialize ( NULL );

    printf(" ------------------------------ \r\n");
    printf("        MCAN FD Demo            \r\n");
    printf(" ------------------------------ \r\n");
    
    /* Set Message RAM Configuration */
    MCAN1_MessageRAMConfigSet(Mcan1MessageRAM);

    MCAN1_RxFifoCallbackRegister(MCAN_RX_FIFO_0, APP_MCAN_RxFifo0Callback, APP_STATE_MCAN_RECEIVE);
    MCAN1_RxFifoCallbackRegister(MCAN_RX_FIFO_1, APP_MCAN_RxFifo1Callback, APP_STATE_MCAN_RECEIVE);
    MCAN1_RxBuffersCallbackRegister(APP_MCAN_RxBufferCallback, APP_STATE_MCAN_RECEIVE);

    display_menu();
    
    while ( true )
    {
        if (state == APP_STATE_MCAN_USER_INPUT)
        {
            /* Read user input */
            scanf("%c", (char *) &user_input);
            
            switch (user_input)
            {
				case '0':
                    memset(txFiFo, 0x00, MCAN1_TX_FIFO_BUFFER_ELEMENT_SIZE);
                    txBuffer = (MCAN_TX_BUFFER *)txFiFo;
                    txBuffer->id = WRITE_ID(0x45A);
                    txBuffer->dlc = MCANLengthToDlcGet(64);
                    txBuffer->fdf = 1;
                    txBuffer->brs = 1;
					for (loop_count = 0; loop_count < 64; loop_count++){
						txBuffer->data[loop_count] = loop_count;
					}                
					printf("  0: Send FD standard message with ID: 0x45A and 64 byte data 0 to 63.\r\n");
                    MCAN1_TxFifoCallbackRegister( APP_MCAN_TxFifoCallback, (uintptr_t)APP_STATE_MCAN_TRANSMIT );
                    state = APP_STATE_MCAN_IDLE;
                    if (MCAN1_MessageTransmitFifo(1, txBuffer) == false)
                    {
                        printf(" Failed \r\n");
                    }             
                    break;
				case '1':
                    memset(txFiFo, 0x00, MCAN1_TX_FIFO_BUFFER_ELEMENT_SIZE);
                    txBuffer = (MCAN_TX_BUFFER *)txFiFo;
                    txBuffer->id = WRITE_ID(0x469);
                    txBuffer->dlc = MCANLengthToDlcGet(64);
                    txBuffer->fdf = 1;
                    txBuffer->brs = 1;
					for (loop_count = 128; loop_count < 192; loop_count++){
						txBuffer->data[loop_count - 128] = loop_count;
					}                
 					printf("  1: Send FD standard message with ID: 0x469 and 64 byte data 128 to 191.\r\n");
					MCAN1_TxFifoCallbackRegister( APP_MCAN_TxFifoCallback, (uintptr_t)APP_STATE_MCAN_TRANSMIT );
                    state = APP_STATE_MCAN_IDLE;
					if (MCAN1_MessageTransmitFifo(1, txBuffer) == false)
                    {
                        printf(" Failed \r\n");
                    }             
                    break;
				case '2':
                    memset(txFiFo, 0x00, MCAN1_TX_FIFO_BUFFER_ELEMENT_SIZE);
                    txBuffer = (MCAN_TX_BUFFER *)txFiFo;
                    txBuffer->id = 0x100000A5;
                    txBuffer->dlc = MCANLengthToDlcGet(64);
                    txBuffer->xtd = 1;
                    txBuffer->fdf = 1;
                    txBuffer->brs = 1;
					for (loop_count = 0; loop_count < 64; loop_count++){
						txBuffer->data[loop_count] = loop_count;
					}
					printf("  2: Send FD extended message with ID: 0x100000A5 and 64 byte data 0 to 63.\r\n");
                    MCAN1_TxFifoCallbackRegister( APP_MCAN_TxFifoCallback, (uintptr_t)APP_STATE_MCAN_TRANSMIT );
                    state = APP_STATE_MCAN_IDLE;
                    if (MCAN1_MessageTransmitFifo(1, txBuffer) == false)
                    {
                        printf(" Failed \r\n");
                    }
                    break;
				case '3':
                    memset(txFiFo, 0x00, MCAN1_TX_FIFO_BUFFER_ELEMENT_SIZE);
                    txBuffer = (MCAN_TX_BUFFER *)txFiFo;
                    txBuffer->id = 0x10000096;
                    txBuffer->dlc = MCANLengthToDlcGet(64);
                    txBuffer->xtd = 1;
                    txBuffer->fdf = 1;
                    txBuffer->brs = 1;
					for (loop_count = 128; loop_count < 192; loop_count++){
						txBuffer->data[loop_count - 128] = loop_count;
					}
					printf("  3: Send FD extended message with ID: 0x10000096 and 64 byte data 128 to 191.\r\n");
                    MCAN1_TxFifoCallbackRegister( APP_MCAN_TxFifoCallback, (uintptr_t)APP_STATE_MCAN_TRANSMIT );
                    state = APP_STATE_MCAN_IDLE;
                    if (MCAN1_MessageTransmitFifo(1, txBuffer) == false)
                    {
                        printf(" Failed \r\n");
                    }
                    break;
				case '4':
                    memset(txFiFo, 0x00, MCAN1_TX_FIFO_BUFFER_ELEMENT_SIZE);
                    txBuffer = (MCAN_TX_BUFFER *)txFiFo;
					txBuffer->id = WRITE_ID(0x469);
                    txBuffer->dlc = 8;
					for (loop_count = 0; loop_count < 8; loop_count++){
						txBuffer->data[loop_count] = loop_count;
					}                
 					printf("  4: Send normal standard message with ID: 0x469 and 8 byte data 0 to 7.\r\n");
					MCAN1_TxFifoCallbackRegister( APP_MCAN_TxFifoCallback, (uintptr_t)APP_STATE_MCAN_TRANSMIT );
                    state = APP_STATE_MCAN_IDLE;
					if (MCAN1_MessageTransmitFifo(1, txBuffer) == false)
                    {
                        printf(" Failed \r\n");
                    }             
                    break;
				case 'm':
				case 'M':
					display_menu();
					break;
					
				default:
					printf(" Invalid Input \r\n");
					break;
            }
        }

        /* Check the application's current state. */
        switch (state)
        {
            case APP_STATE_MCAN_IDLE:
            {
                /* Application can do other task here */
                break;
            }
            case APP_STATE_MCAN_XFER_SUCCESSFUL:
            {
                if ((APP_STATES)xferContext == APP_STATE_MCAN_TRANSMIT)
                {
                    printf(" Success\r\n");
                }                
                state = APP_STATE_MCAN_USER_INPUT;
                break;
            }
            case APP_STATE_MCAN_XFER_ERROR:
            {
                if ((APP_STATES)xferContext == APP_STATE_MCAN_RECEIVE)
                {
                    printf(" Error in received message\r\n");
                }
                else
                {
                    printf(" Failed\r\n");
                }
                state = APP_STATE_MCAN_USER_INPUT;
                break;
            }
            default:
            {
                break;
            }
        }
    }

    /* Execution should not come here during normal operation */

    return ( EXIT_FAILURE );
}
```

**Library Interface**

Controller Area Network peripheral library provides the following interfaces:

**Functions**

|Name|Description|
|----|-----------|
|MCANx\_Initialize|Initializes given instance of the MCAN peripheral|
|MCANx\_MessageTransmit|Transmits a message into CAN bus from the specific Tx buffer|
|MCANx\_MessageTransmitFifo|Transmit multiple messages into CAN bus from Tx FIFO|
|MCANx\_TxFifoFreeLevelGet|Returns Tx FIFO Free Level|
|MCANx\_TxBufferIsBusy|Check if Transmission request is pending for the specific Tx buffer|
|MCANx\_TxEventFifoRead|Read Tx Event FIFO for the transmitted messages|
|MCANx\_TxEventFifoFillLevelGet|Returns Tx Event FIFO Fill Level|
|MCANx\_MessageReceive|Read a message from the specific Rx Buffer|
|MCANx\_RxBufferNumberGet|Get Rx Buffer Number|
|MCANx\_MessageReceiveFifo|Read messages from Rx FIFO0/FIFO1|
|MCANx\_RxFifoFillLevelGet|Returns Rx FIFO0/FIFO1 Fill Level|
|MCANx\_ErrorGet|Returns the error during transfer|
|MCANx\_ErrorCountGet|Returns the transmit and receive error count during transfer|
|MCANx\_InterruptGet|Returns the Interrupt status|
|MCANx\_InterruptClear|Clears Interrupt status|
|MCANx\_MessageRAMConfigSet|Set the Message RAM Configuration|
|MCANx\_StandardFilterElementSet|Set a standard filter element configuration|
|MCANx\_StandardFilterElementGet|Get a standard filter element configuration|
|MCANx\_ExtendedFilterElementSet|Set a Extended filter element configuration|
|MCANx\_ExtendedFilterElementGet|Get a Extended filter element configuration|
|MCANx\_SleepModeEnter|Puts the MCAN Peripheral in sleep mode \(clock stop request\)|
|MCANx\_SleepModeExit|Exits MCAN peripheral from sleep mode \(clock stop request\)|
|MCANx\_TxBuffersCallbackRegister|Sets the pointer to the function \(and it's contextHandle\) to be called when the given MCAN's Tx transfer events occur|
|MCANx\_TxFifoCallbackRegister|Sets the pointer to the function \(and it's contextHandle\) to be called when the given MCAN's Tx transfer events occur|
|MCANx\_TxEventFifoCallbackRegister|Sets the pointer to the function \(and it's contextHandle\) to be called when the given MCAN's Tx transfer events occur|
|MCANx\_RxBuffersCallbackRegister|Sets the pointer to the function \(and it's contextHandle\) to be called when the given MCAN's Rx transfer events occur|
|MCANx\_RxFifoCallbackRegister|Sets the pointer to the function \(and it's contextHandle\) to be called when the given MCAN's Rx transfer events occur|

**Data types and constants**

|Name|Type|Description|
|----|----|-----------|
|MCAN\_ERROR\_NONE|Macro|MCAN Error None|
|MCAN\_ERROR\_LEC\_STUFF|Macro|MCAN Error LEC\_STUFF|
|MCAN\_ERROR\_LEC\_ACK|Macro|MCAN Error LEC\_ACK|
|MCAN\_ERROR\_LEC\_BIT1|Macro|MCAN Error LEC\_BIT1|
|MCAN\_ERROR\_LEC\_BIT0|Macro|MCAN Error LEC\_BIT0|
|MCAN\_ERROR\_LEC\_FORM|Macro|MCAN Error LEC\_FORM|
|MCAN\_ERROR\_LEC\_CRC|Macro|MCAN Error LEC\_CRC|
|MCAN\_ERROR\_LEC\_NO\_CHANGE|Macro|MCAN Error LEC\_NO\_CHANGE|
|MCAN\_ERROR\_WARNING\_STATUS|Macro|MCAN Error WARNING\_STATUS|
|MCAN\_ERROR\_PASSIVE|Macro|MCAN Error PASSIVE|
|MCAN\_ERROR\_BUS\_OFF|Macro|MCAN Error BUS\_OFF|
|MCAN\_ERROR\_DLEC\_STUFF|Macro|MCAN Error DLEC\_STUFF|
|MCAN\_ERROR\_DLEC\_ACK|Macro|MCAN Error DLEC\_ACK|
|MCAN\_ERROR\_DLEC\_BIT1|Macro|MCAN Error DLEC\_BIT1|
|MCAN\_ERROR\_DLEC\_BIT0|Macro|MCAN Error DLEC\_BIT0|
|MCAN\_ERROR\_DLEC\_FORM|Macro|MCAN Error DLEC\_FORM|
|MCAN\_ERROR\_DLEC\_CRC|Macro|MCAN Error DLEC\_CRC|
|MCAN\_ERROR\_DLEC\_NO\_CHANGE|Macro|MCAN Error DLEC\_NO\_CHANGE|
|MCAN\_ERROR\_PROTOCOL\_EXCEPTION\_EVENT|Macro|MCAN Error PROTOCOL\_EXCEPTION\_EVENT|
|MCAN\_ERROR\_INVALID|Macro|MCAN Error Invalid|
|MCAN\_RX\_FIFO\_NUM|Enum|MCAN Rx FIFO Number|
|MCAN\_INTERRUPT\_MASK|Enum|MCAN Interrupt Mask|
|MCAN\_ERROR|Typedef|MCAN Transfer Error data type|
|MCAN\_TX\_FIFO\_CALLBACK|Typedef|MCAN Callback Function Pointer for Tx FIFO|
|MCAN\_TXRX\_BUFFERS\_CALLBACK|Typedef|MCAN Callback Function Pointer for TX/RX Buffers|
|MCAN\_TX\_EVENT\_FIFO\_CALLBACK|Typedef|MCAN Callback Function Pointer for Tx Event FIFO|
|MCAN\_RX\_FIFO\_CALLBACK|Typedef|MCAN Callback Function Pointer for Rx FIFO0/FIFO1|
|MCAN\_MSG\_RAM\_CONFIG|Struct|MCAN Message RAM Configuration structure|
|MCAN\_RX\_BUFFER|Struct|MCAN Rx Buffer and FIFO Element Structure|
|MCAN\_TX\_BUFFER|Struct|MCAN Tx Buffer Element Structure|
|MCAN\_TX\_EVENT\_FIFO|Struct|MCAN Tx Event FIFO Element Structure|
|MCAN\_TX\_FIFO\_CALLBACK\_OBJ|Struct|MCAN transfer event callback structure for Tx FIFO|
|MCAN\_TXRX\_BUFFERS\_CALLBACK\_OBJ|Struct|MCAN transfer event callback structure for Tx/Rx Buffers|
|MCAN\_TX\_EVENT\_FIFO\_CALLBACK\_OBJ|Struct|MCAN transfer event callback structure for Tx Event FIFO|
|MCAN\_RX\_FIFO\_CALLBACK\_OBJ|Struct|MCAN transfer event callback structure for Rx FIFO0/FIFO1|

-   **[MCANx\_Initialize Function](GUID-38EC1944-305F-4F46-AF19-312861DDEB2D.md)**  

-   **[MCANx\_MessageTransmit Function](GUID-D788FA41-56A2-45F5-B680-1C7C01C7F5B5.md)**  

-   **[MCANx\_MessageTransmitFifo Function](GUID-377F90D1-3588-4AF2-89EE-D8BD12C63F64.md)**  

-   **[MCANx\_TxFifoFreeLevelGet Function](GUID-6C616083-6B9C-4C2F-A176-4A8CD515F7E6.md)**  

-   **[MCANx\_TxBufferIsBusy Function](GUID-E97F53C2-78CE-4FB5-BE1A-CA501AE923A3.md)**  

-   **[MCANx\_TxEventFifoRead Function](GUID-BE38EB95-FD2A-421F-BC3A-67B65C28E0AA.md)**  

-   **[MCANx\_TxEventFifoFillLevelGet Function](GUID-CC2F27B5-3CC4-4D02-B462-1388B00C0E2A.md)**  

-   **[MCANx\_MessageReceive Function](GUID-2719699B-5BE3-451C-B9E7-378599191270.md)**  

-   **[MCANx\_RxBufferNumberGet Function](GUID-35B57061-978A-4127-B96B-5F3DD396FCDF.md)**  

-   **[MCANx\_MessageReceiveFifo Function](GUID-5A5C0590-3244-41C2-8DC3-11D5985B71FD.md)**  

-   **[MCANx\_RxFifoFillLevelGet Function](GUID-C42A4B07-DEAF-4469-8298-0E163223C311.md)**  

-   **[MCANx\_ErrorGet Function](GUID-5A4BFC0F-CF88-408D-BDA9-811C13C819FE.md)**  

-   **[MCANx\_ErrorCountGet Function](GUID-BB120D3D-85FB-42EB-BC57-E27119C64A4C.md)**  

-   **[MCANx\_InterruptGet Function](GUID-29D5F8C0-AB14-4544-8865-B09487E7EB6B.md)**  

-   **[MCANx\_InterruptClear Function](GUID-2EFB7945-96A8-4A4F-B125-B32B6848A5FF.md)**  

-   **[MCANx\_MessageRAMConfigSet Function](GUID-1B31ADC6-FA17-4EC1-8B4D-A9AC8ADCD54E.md)**  

-   **[MCANx\_StandardFilterElementSet Function](GUID-17840C99-702F-40D3-8ECE-B26744B11DE9.md)**  

-   **[MCANx\_StandardFilterElementGet Function](GUID-98231716-81D5-4FA0-8E05-212152A01181.md)**  

-   **[MCANx\_ExtendedFilterElementSet Function](GUID-1EFA1684-8A46-4CB4-AF9E-BF6E1B840105.md)**  

-   **[MCANx\_ExtendedFilterElementGet Function](GUID-419214A5-71EE-459E-9568-E2D372B65A63.md)**  

-   **[MCANx\_SleepModeEnter Function](GUID-FF8FB12A-59AF-41BA-A44B-473BA04EB4FF.md)**  

-   **[MCANx\_SleepModeExit Function](GUID-E442D3A1-E12F-4469-86EE-BF870E932040.md)**  

-   **[MCANx\_TxBuffersCallbackRegister Function](GUID-680CA3C9-B046-4B02-BC29-300470BFD65B.md)**  

-   **[MCANx\_TxFifoCallbackRegister Function](GUID-B0ADC363-E236-49BC-8A0C-7A64372904EB.md)**  

-   **[MCANx\_TxEventFifoCallbackRegister Function](GUID-302EDA73-32A3-4C47-9B5B-8D02F7859151.md)**  

-   **[MCANx\_RxBuffersCallbackRegister Function](GUID-4D1AF36C-698F-4BB7-954D-366B1BFF435C.md)**  

-   **[MCANx\_RxFifoCallbackRegister Function](GUID-D97D09D3-FEA6-42D5-9660-22BB0565D113.md)**  

-   **[MCAN\_ERROR\_NONE Macro](GUID-A77EE920-1EB0-4596-83F6-50EDCE2FE3E3.md)**  

-   **[MCAN\_ERROR\_LEC\_STUFF Macro](GUID-3999E719-9A66-430C-91AA-FCB27F8DC923.md)**  

-   **[MCAN\_ERROR\_LEC\_BIT1 Macro](GUID-464691E8-E9C7-4585-8A9D-07DC93B3CBF0.md)**  

-   **[MCAN\_ERROR\_LEC\_BIT0 Macro](GUID-E0B418DF-1E3F-4347-94DC-313DDB330F14.md)**  

-   **[MCAN\_ERROR\_LEC\_ACK Macro](GUID-2258E12B-55CE-4A72-B7DC-AC82DD432EA0.md)**  

-   **[MCAN\_ERROR\_LEC\_FORM Macro](GUID-F56321C4-4206-4BAF-AC3C-4DE380078B6A.md)**  

-   **[MCAN\_ERROR\_LEC\_CRC Macro](GUID-238B4837-62EA-410D-B071-44213501ED11.md)**  

-   **[MCAN\_ERROR\_LEC\_NO\_CHANGE Macro](GUID-11876C7B-8CB1-4C9F-9036-D086E00D2AFD.md)**  

-   **[MCAN\_ERROR\_WARNING\_STATUS Macro](GUID-92099E6A-2782-487E-856C-2476F32DC804.md)**  

-   **[MCAN\_ERROR\_PASSIVE Macro](GUID-5DFA7D4E-E353-43FA-A824-E7E98402DA11.md)**  

-   **[MCAN\_ERROR\_BUS\_OFF Macro](GUID-74D58578-E86D-4686-BF91-375ED2384030.md)**  

-   **[MCAN\_ERROR\_DLEC\_STUFF Macro](GUID-7E9D9947-987B-4D0E-8377-BFFF3CFCA190.md)**  

-   **[MCAN\_ERROR\_DLEC\_ACK Macro](GUID-D66FEF49-9C32-41E0-BC75-FE86BB5B8682.md)**  

-   **[MCAN\_ERROR\_DLEC\_BIT1 Macro](GUID-7E460927-D5AE-43F1-B07D-CFA71F8CDFE8.md)**  

-   **[MCAN\_ERROR\_DLEC\_BIT0 Macro](GUID-C4741DBD-6382-4FEF-8D85-B1394DD1F231.md)**  

-   **[MCAN\_ERROR\_DLEC\_FORM Macro](GUID-0CD0F7BE-3BA4-41B3-9029-1EE96553F54F.md)**  

-   **[MCAN\_ERROR\_DLEC\_CRC Macro](GUID-AF95F6E9-A74E-44F1-9D72-DB59E7B1CBAB.md)**  

-   **[MCAN\_ERROR\_DLEC\_NO\_CHANGE Macro](GUID-B6043909-B840-4BEA-B691-9A8CD84D60EB.md)**  

-   **[MCAN\_ERROR\_PROTOCOL\_EXCEPTION\_EVENT Macro](GUID-0E374F13-C4A1-44E6-BC4F-E75F91EB391A.md)**  

-   **[MCAN\_RX\_FIFO\_NUM Enum](GUID-841AE7A0-131A-4981-9E08-D149B964C9D6.md)**  

-   **[MCAN\_INTERRUPT\_MASK Enum](GUID-0A4FC5B5-0F2B-4446-863F-354F28D27A83.md)**  

-   **[MCAN\_ERROR\_INVALID Macro](GUID-62013B71-0377-4DEA-A46C-60E23586CB9D.md)**  

-   **[MCAN\_ERROR Typedef](GUID-D11993BA-2DB9-4E43-8ED5-A96334A43840.md)**  

-   **[MCAN\_TX\_FIFO\_CALLBACK Typedef](GUID-0573934C-0C03-4FE0-98D6-F3AC68C9A91C.md)**  

-   **[MCAN\_TXRX\_BUFFERS\_CALLBACK Typedef](GUID-140598E0-8262-416E-B749-F870FFEB3D3C.md)**  

-   **[MCAN\_TX\_EVENT\_FIFO\_CALLBACK Typedef](GUID-8E0CAF7A-5B1D-471D-BE2F-54AE2BB9CEFD.md)**  

-   **[MCAN\_RX\_FIFO\_CALLBACK Typedef](GUID-606AD511-4607-4FCB-8F5E-1B6947968285.md)**  

-   **[MCAN\_MSG\_RAM\_CONFIG Struct](GUID-AC08889E-BB67-4D3A-A026-74D063E82F85.md)**  

-   **[MCAN\_RX\_BUFFER Struct](GUID-34962F57-5141-4A23-9DF9-07994F41DDB7.md)**  

-   **[MCAN\_TX\_BUFFER Struct](GUID-838F954C-5ED4-47DD-B673-EC6069E0D4A9.md)**  

-   **[MCAN\_TX\_EVENT\_FIFO Struct](GUID-CB448CA7-9B89-4B3B-B31E-5DA33508C19E.md)**  

-   **[MCAN\_TX\_FIFO\_CALLBACK\_OBJ Struct](GUID-5B987702-269C-424A-BBDA-5481E26F0EB1.md)**  

-   **[MCAN\_TXRX\_BUFFERS\_CALLBACK\_OBJ Struct](GUID-35E1F338-E728-48FB-939A-2069AAD097CC.md)**  

-   **[MCAN\_TX\_EVENT\_FIFO\_CALLBACK\_OBJ Struct](GUID-469F41EB-E689-443B-BB74-2A06A636D17B.md)**  

-   **[MCAN\_RX\_FIFO\_CALLBACK\_OBJ Struct](GUID-BB8F3B91-8824-408B-990C-51E30E49E494.md)**  


**Parent topic:**[SAM 9X7 Peripheral Libraries](GUID-FB6741AA-355E-483F-9727-37728953D583.md)

**Parent topic:**[SAM A5D2 Peripheral Libraries](GUID-F6605EDC-FC71-4081-8560-0C1681C1FA8D.md)

**Parent topic:**[SAM A7G5 Peripheral Libraries](GUID-7EEB1AC5-4BFF-4259-97AD-8CF7367D7973.md)

**Parent topic:**[SAM E70 S70 V70 V71 Peripheral Libraries](GUID-6E45C146-6F6D-452A-A2E2-228C3CC905D7.md)

**Parent topic:**[SAM RH707 Peripheral Libraries](GUID-C2AC236D-363B-4378-A381-B281F67C8647.md)

**Parent topic:**[SAM RH71 Peripheral Libraries](GUID-AC9BE324-E486-46EA-8D16-E04E15288053.md)

