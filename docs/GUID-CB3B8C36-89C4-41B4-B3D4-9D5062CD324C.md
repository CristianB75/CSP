# MCSPIx\_Write Function

**Parent topic:**[Multi Channel Serial Peripheral Interface \(MCSPI\)](GUID-A3A5277D-BAE3-4BD0-91E9-D4E7E0608BE7.md)

## C

```c
/* x = MCSPI instance number */

/* MCSPI master mode */
bool MCSPIx_Write(void* pWrBuffer, size_t txSize)		
```

```c
/* x = MCSPI instance number */

/* MCSPI slave mode */
size_t MCSPIx_Write(void* pWrBuffer, size_t txSize )			
```

## Summary

Writes data to MCSPI peripheral

## Description

*MCSPI master mode*

This function writes "txSize" number of bytes on MCSPI module. Data pointed by pWrBuffer is transmitted. When interrupt is disabled, this function will be blocking in nature. In this mode, the function will not return until all the requested data is transferred. The function returns true after transferring all the data. This indicates that the operation has been completed. When interrupt is enabled, the function will be non-blocking in nature. The function returns immediately. The data transfer process continues in the peripheral interrupt. The application specified transmit buffer is owned by the library until the data transfer is complete and should not be modified by the application till the transfer is complete. Only one transfer is allowed at any time. The application can use a callback function or a polling function to check for completion of the transfer. If a callback is required, this should be registered prior to calling the MCSPIx\_Write\(\) function. The application can use the MCSPIx\_IsBusy\(\) to poll for completion of transfer.

*MCSPI slave mode*

This function writes "txSize" number of bytes on MCSPI module. Data pointed by pWrBuffer is transmitted. This function returns immediately after copying the data pointed by pWrBuffer into the PLIB's internal buffer. The actual data transfer happens when a MCSPI transfer is initiated by the MCSPI master. Upon completion a callback is given to the application.

## Precondition

The MCSPIx\_Initialize function must have been called.

*MCSPI master mode*

Callback can be registered using MCSPIx\_CallbackRegister API if the PLIB is configured in Interrupt mode and transfer completion status needs to be communicated back to application via callback.

*MCSPI slave mode*

Callback must have been registered using MCSPIx\_CallbackRegister API to get notified when the transfer is complete.

## Parameters

*MCSPI master mode*

|Param|Description|
|-----|-----------|
|pWrBuffer|Pointer to the buffer containing the data which has to betransmitted. In "Interrupt Mode", this buffer should not be modified after calling the function and before the callback function has been called or the MCSPIx\_IsBusy\(\) function returns false.|
|txSize|Number of bytes to be transmitted. This value is the byte size of the buffer irrespective of 8/16/32 bit transfer mode.|

*MCSPI slave mode*

|Param|Description|
|-----|-----------|
|pWrBuffer|Pointer to the buffer where the data must be copied to the PLIB's internal buffer|
|txSize|Number of bytes to copy. If 16/32 bit modes are supported, the rxSize must be specified in terms of 16/32 bit words.|

## Returns

*MCSPI master mode*

*true* - If configured for Non-interrupt mode, the function has transmitted the requested number of bytes. If configured for Interrupt mode, the request was accepted successfully and will be processed in the interrupt.

*false* - If pWrBuffer is NULL or txSize is 0. In Interrupt mode, the function will additionally return false if there is an on-going data transfer at the time of calling the function.

*MCSPI slave mode*

Returns the number of bytes actually copied from the pWrBuffer. If 16/32 bit modes are supported, the return value is specified in terms of 16/32 bit words.

## Example

*MCSPI master mode*

```c
uint8_t txBuffer[4];
size_t txSize = 4;

void APP_MCSPITransferHandler(uintptr_t context)
{
    //Transfer was completed without error, do something else now.
}

MCSPI1_Initialize();
MCSPI1_CallbackRegister(&APP_MCSPITransferHandler, (uintptr_t)NULL);
if(MCSPI1_Write(&txBuffer, txSize))
{
    // request got accepted
}
else
{
    // request didn't get accepted, try again later with correct arguments
}

```

*MCSPI slave mode*

```c
uint8_t APP_TxData[4];
uint8_t APP_RxData[10];
size_t txSize = 4;

void MCSPIEventHandler(uintptr_t context )
{
    if (MCSPI1_ErrorGet() == MCSPI_SLAVE_ERROR_NONE)
    {
        // Read out the received data. This could be meaningful data if MCSPI master is
        // writing to slave or it could be dummy data if MCSPI master is reading from slave.
        // However, irrespective of whether slave is expecting meaningful data or dummy
        // data from master, MCSPI slave must always read out the data to clear the PLIB's
        // internal receive buffer.

        appData.nBytesRead = MCSPI1_Read(APP_RxData, MCSPI1_ReadCountGet());
    }
    else
    {
        // Handle error
    }

}

MCSPI1_CallbackRegister(MCSPIEventHandler, (uintptr_t) 0);
MCSPI1_Write(APP_TxData, txSize);
```

## Remarks

*MCSPI slave mode*

This function returns immediately. Application must register a callback to get notified, when the data transfer is complete. A data transfer is considered as complete, when the Chip Select line is driven to inactive state by the MCSPI master.

