<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html
  PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />

<meta http-equiv="X-UA-Compatible" content="IE=EmulateIE11" /><meta name="copyright" content="(C) Copyright 2022" />
<meta name="DC.rights.owner" content="(C) Copyright 2022" />
<meta name="DC.type" content="topic" />
<meta name="DC.title" content="SERCOMx_SPI_Write Function" />
<meta name="DC.format" content="XHTML" />
<meta name="DC.identifier" content="sercomx-spi-write-function" />
<link rel="stylesheet" type="text/css" href="stylesheets/commonltr.css" />
<link rel="stylesheet" type="text/css" href="stylesheets/atmel.css" />
<link rel="stylesheet" type="text/css" href="./stylesheets/common-extended.css" /><title>SERCOMx_SPI_Write Function</title>
<meta name="Microsoft.Help.Id" content="GUID-1EA9B250-D935-443A-9FA9-C48E50D229E8-sercomx-spi-write-function" />
<meta name="Microsoft.Help.TocParent" content="GUID-1EA9B250-D935-443A-9FA9-C48E50D229E8" />
<meta name="Microsoft.Help.TocOrder" content="0" />
<meta name="Microsoft.Help.Locale" content="en-US" />
<meta name="Microsoft.Help.TopicLocale" content="en-US" />
<meta name="Microsoft.Help.DisplayVersion" content="MPLABÂ® Harmony Peripheral Libraries Reference A 09/2021" />
<script language="javascript">
       
       if (window.parent.location.protocol != 'file:') {
				document.addEventListener('click', function(e) {
				    if (e.target) {
               if (e.target.nodeName == "A" ) {
                    if (!e.target.target) {
                      e.preventDefault();
                      e.stopPropagation();
                              
                      var origUrl = window.parent.location.href.substr(0, window.parent.location.href.indexOf("?"));
                      if (origUrl.length === 0) {
                          origUrl = window.parent.location.href;
                      }
                      var href= e.target.getAttribute("href");
                      var parts = href.split("#");
          
                      var url = "";
                      if (parts.length == 2 ) {
                        if (!parts[0].length) {
                            url = window.parent.location.search.replace('?','')
                        } else {
                            url = parts[0].replace('.html','');
                        }
                      } else {
                        url = parts[0].replace('.html','');
                      }

                      if (parts.length == 2) {
                          url += "#" + parts[1];
                      }
    
                      window.parent.location.href = origUrl + "?" + url;

                      return false;
                    }
               }
            }
				});
			}

		</script><script language="javascript">
        function cpy(id, button) {
        
            var element = document.getElementById(id);
            var content = element.getAttribute("content");
            var textArea = document.createElement("textarea");
            
            // Place in the top-left corner of screen regardless of scroll position.
            textArea.style.position = 'fixed';
            textArea.style.top = 0;
            textArea.style.left = 0;
            
            // Ensure it has a small width and height. Setting to 1px / 1em
            // doesn't work as this gives a negative w/h on some browsers.
            textArea.style.width = '2em';
            textArea.style.height = '2em';
            
            // We don't need padding, reducing the size if it does flash render.
            textArea.style.padding = 0;
            
            // Clean up any borders.
            textArea.style.border = 'none';
            textArea.style.outline = 'none';
            textArea.style.boxShadow = 'none';
            
            // Avoid flash of the white box if rendered for any reason.
            textArea.style.background = 'transparent';
            
            
            textArea.value = content;
            
            document.body.appendChild(textArea);
            textArea.focus();
            textArea.select();
            
            try {
               var successful = document.execCommand('copy');
               var msg = successful ? 'successful' : 'unsuccessful';
               if (!button.classList.contains("copied")){
                  button.textContent = "Copied";
                  button.classList.add("copied");
                  setTimeout(function(){
                    button.textContent = "Copy";
                    button.classList.remove("copied");
                  },1000);
               }
            } catch (err) {
              console.log('Oops, unable to copy');
            }
            
            document.body.removeChild(textArea);
        }
      </script><script language="javascript">
          
          // Add the MathML namespace to html
          var html = document.getElementsByTagName("html")[0],
          head = document.getElementsByTagName("head")[0];
          
          var mathJax = document.createElement("script");
          mathJax.src = "https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-MML-AM_CHTML";
          head.appendChild(mathJax);
          
          html.setAttribute("xmlns:m","http://www.w3.org/1998/Math/MathML");
          
          function inIframe() { try { return window.self !== window.top; } catch (e) { return true; } }
          
          if (!inIframe()) { 
          
          var Default = "index.html?GUID-7307216F-6A46-41E3-803D-455CBE019F54"; 
          
          var displaylocation = "value" + window.location.href;
          
          var GUIDS = displaylocation.split('GUID');          
          
          if (displaylocation.indexOf('#GUID') != -1) {            
          var First = GUIDS[1].split('.html');  
          if (GUIDS[3]){First = GUIDS[2].split('.html');}
          if (GUIDS[4]){First = GUIDS[3].split('.html');}
          if (GUIDS[5]){First = GUIDS[4].split('.html');}
          
          var Second = GUIDS[2].split('#');   
          if (GUIDS[3]){Second = GUIDS[3].split('#');}
          if (GUIDS[4]){Second = GUIDS[4].split('#');}
          if (GUIDS[5]){Second = GUIDS[5].split('#');}
          
          Default = "index.html?" + "GUID" + First[0] + "GUID" + Second[0];     
          }                    
          window.top.location = Default;
          }       
          
        </script><style xml:space="">
        
          button.copy-code{
            display:none;
            padding:0.7em 1.4em;
            margin:0 0.3em 0.3em 0;
            border-radius:0.15em;
            box-sizing: border-box;
            text-decoration:none;
            font-family:'Roboto',sans-serif;
            text-transform:uppercase;
            font-weight:400;
            color:#FFFFFF;
            background-color:#9c9c9c;
            box-shadow:inset 0 -0.6em 0 -0.35em rgba(0,0,0,0.17);
            text-align:center;
            position:relative;
            border: 0;
            float: right;
            border-radius: .5em;
            cursor: pointer;
          }
          button.copy-code:active{
            top:0.1em;
          }
          
          pre:hover button.copy-code{
            display: inline-block !important;
          }
          button.copy-code.copied {
            cursor: default !important;
          }
          
          
          @media all and (max-width:30em){
            button.copy-code{
              display:block;
              margin:0.4em auto;
            }
          }
        
        
      </style></head>
<body id="sercomx-spi-write-function">
<h1 class="title topictitle1" id="ariaid-title1">SERCOMx_SPI_Write Function</h1><div class="body"></div>
<div class="topic nested1" aria-labelledby="ariaid-title2" id="c"><h2 class="title topictitle2" id="ariaid-title2">C</h2><div class="body"><pre class="pre codeblock language-c"><button title="Copy Code" class="copy-code" onclick="cpy('d725539e14', this);">Copy</button><code id="d725539e14" content="/* x = SERCOM instance number */&#xA;&#xA;/* SPI master mode */&#xA;bool SERCOMx_SPI_Write(void* pWrBuffer, size_t txSize)&#x9;&#x9;"><span class="ph token comment">/* x = SERCOM instance number */</span>

<span class="ph token comment">/* SPI master mode */</span>
bool <span class="ph token function">SERCOMx_SPI_Write</span><span class="ph token punctuation">(</span><span class="ph token keyword">void</span><span class="ph token operator">*</span> pWrBuffer<span class="ph token punctuation">,</span> size_t txSize<span class="ph token punctuation">)</span>		</code></pre><pre class="pre codeblock language-c"><button title="Copy Code" class="copy-code" onclick="cpy('d725539e37', this);">Copy</button><code id="d725539e37" content="/* x = SERCOM instance number */&#xA;&#xA;/* SPI slave mode */&#xA;size_t SERCOMx_SPI_Write(void* pWrBuffer, size_t txSize )&#x9;&#x9;&#x9;"><span class="ph token comment">/* x = SERCOM instance number */</span>

<span class="ph token comment">/* SPI slave mode */</span>
size_t <span class="ph token function">SERCOMx_SPI_Write</span><span class="ph token punctuation">(</span><span class="ph token keyword">void</span><span class="ph token operator">*</span> pWrBuffer<span class="ph token punctuation">,</span> size_t txSize <span class="ph token punctuation">)</span>			</code></pre></div>
</div>
<div class="topic nested1" aria-labelledby="ariaid-title3" id="summary"><h2 class="title topictitle2" id="ariaid-title3">Summary</h2><div class="body"><p class="p">Writes data to SERCOM SPI peripheral.</p>
</div>
</div>
<div class="topic nested1" aria-labelledby="ariaid-title4" id="description"><h2 class="title topictitle2" id="ariaid-title4">Description</h2><div class="body"><p class="p"><em class="ph i">SPI master mode</em></p>
<p class="p">This function writes "txSize" number of bytes on SERCOM x SPI module. Data pointed by pWrBuffer is transmitted.  When interrupt is disabled, this function will be blocking in nature. In this mode, the function will not return until all the requested data is transferred. The function returns true after transferring all the data. This indicates that the operation has been completed.  When interrupt is enabled, the function will be non-blocking in nature. The function returns immediately. The data transfer process continues in the peripheral interrupt. The application specified transmit buffer is owned by the library until the data transfer is complete and should not be modified by the application till the transfer is complete. Only one transfer is allowed at any time. The application can use a callback function or a polling function to check for completion of the transfer. If a callback is required, this should be registered prior to calling the SERCOMx_SPI_WriteRead() function. The application can use the SERCOMx_SPI_IsBusy() to poll for completion of transfer.</p>
<p class="p"><em class="ph i">SPI slave mode</em></p>
<p class="p">This function writes "txSize" number of bytes on SERCOM x SPI module. Data pointed by pWrBuffer is transmitted. This function returns immediately after copying the data pointed by pWrBuffer into the PLIB's internal buffer. The actual data transfer happens when a SPI transfer is initiated by the SPI master. Upon completion a callback is given to the application.</p>
</div>
</div>
<div class="topic nested1" aria-labelledby="ariaid-title5" id="precondition"><h2 class="title topictitle2" id="ariaid-title5">Precondition</h2><div class="body"><p class="p">The SERCOMx_SPI_Initialize function must have been called.</p>
<p class="p"><em class="ph i">SPI master mode</em></p>
<p class="p">Callback can be registered using SERCOMx_SPI_CallbackRegister API if the PLIB is configured in Interrupt mode and transfer completion status needs to be communicated back to application via callback.</p>
<p class="p"><em class="ph i">SPI slave mode</em></p>
<p class="p">Callback must have been registered using SERCOMx_SPI_CallbackRegister API to get notified when the transfer is complete.</p>
</div>
</div>
<div class="topic nested1" aria-labelledby="ariaid-title6" id="parameters"><h2 class="title topictitle2" id="ariaid-title6">Parameters</h2><div class="body"><p class="p"><em class="ph i">SPI master mode</em></p>

<div class="tablenoborder"><table cellpadding="4" cellspacing="0" summary="" class="table" frame="border" border="1" rules="all"><col style="width:" /><col style="width:" /><thead class="thead" style="text-align:left;"><tr class="row"><th class="entry cellrowborder" style="text-align:left;vertical-align:middle;" id="d725539e109"><span>Param</span></th>
<th class="entry cellrowborder" style="text-align:left;vertical-align:middle;" id="d725539e111"><span>Description</span></th>
</tr>
</thead>
<tbody class="tbody"><tr class="row"><td class="entry cellrowborder" style="text-align:left;vertical-align:middle;" headers="d725539e109 "><span>pWrBuffer</span></td>
<td class="entry cellrowborder" style="text-align:left;vertical-align:middle;" headers="d725539e111 "><span>Pointer to the buffer containing the data which has to betransmitted. For 9 bit mode, data should be right aligned in the 16 bit memory location. In "Interrupt Mode", this buffer should not be modified after calling the function and before the callback function has been called or the SERCOMx_SPI_IsBusy() function returns false.</span></td>
</tr>
<tr class="row"><td class="entry cellrowborder" style="text-align:left;vertical-align:middle;" headers="d725539e109 "><span>txSize</span></td>
<td class="entry cellrowborder" style="text-align:left;vertical-align:middle;" headers="d725539e111 "><span>Number of bytes to be transmitted. This value is always the bytecount of the buffer. For 9 bit data length, this should be an even number.</span></td>
</tr>
</tbody>
</table>
</div>
<p class="p"><em class="ph i">SPI slave mode</em></p>

<div class="tablenoborder"><table cellpadding="4" cellspacing="0" summary="" class="table" frame="border" border="1" rules="all"><col style="width:" /><col style="width:" /><thead class="thead" style="text-align:left;"><tr class="row"><th class="entry cellrowborder" style="text-align:left;vertical-align:middle;" id="d725539e133"><span>Param</span></th>
<th class="entry cellrowborder" style="text-align:left;vertical-align:middle;" id="d725539e135"><span>Description</span></th>
</tr>
</thead>
<tbody class="tbody"><tr class="row"><td class="entry cellrowborder" style="text-align:left;vertical-align:middle;" headers="d725539e133 "><span>pWrBuffer</span></td>
<td class="entry cellrowborder" style="text-align:left;vertical-align:middle;" headers="d725539e135 "><span>Pointer to the buffer where the data must be copied to the PLIB's internal buffer</span></td>
</tr>
<tr class="row"><td class="entry cellrowborder" style="text-align:left;vertical-align:middle;" headers="d725539e133 "><span>txSize</span></td>
<td class="entry cellrowborder" style="text-align:left;vertical-align:middle;" headers="d725539e135 "><span>Number of bytes to copy. For 9-bit mode, the txSize must be specified in terms of 16-bit words.</span></td>
</tr>
</tbody>
</table>
</div>
</div>
</div>
<div class="topic nested1" aria-labelledby="ariaid-title7" id="returns"><h2 class="title topictitle2" id="ariaid-title7">Returns</h2><div class="body"><p class="p"><em class="ph i">SPI master mode</em></p>
<p class="p"><em class="ph i">true</em> - If configured for Non-interrupt mode, the function has transmitted the requested number of bytes. If configured for Interrupt mode, the request was accepted successfully and will be processed in the interrupt.
<em class="ph i">false</em> - If pWrBuffer is NULL or txSize is 0. In Interrupt mode, the function will additionally return false if there is an on-going data transfer at the time of calling the function.</p>
<p class="p"><em class="ph i">SPI slave mode</em></p>
<p class="p">Returns the number of bytes (or 16-bit words if PLIB is in 9-bit mode) actually copied into the pWrBuffer</p>
</div>
</div>
<div class="topic nested1" aria-labelledby="ariaid-title8" id="example"><h2 class="title topictitle2" id="ariaid-title8">Example</h2><div class="body"><p class="p"><em class="ph i">SPI master mode</em></p>
<pre class="pre codeblock language-c"><button title="Copy Code" class="copy-code" onclick="cpy('d725539e174', this);">Copy</button><code id="d725539e174" content="uint8_t txBuffer[4];&#xA;size_t txSize = 4;&#xA;&#xA;void APP_SPITransferHandler(uintptr_t context)&#xA;{&#xA;    //Transfer was completed without error, do something else now.&#xA;}&#xA;&#xA;SERCOM0_SPI_Initialize();&#xA;SERCOM0_SPI_CallbackRegister(&amp;APP_SPITransferHandler, (uintptr_t)NULL);&#xA;if(SERCOM0_SPI_Write(&amp;txBuffer, txSize))&#xA;{&#xA;    // request got accepted&#xA;}&#xA;else&#xA;{&#xA;    // request didn't get accepted, try again later with correct arguments&#xA;}&#xA;">uint8_t txBuffer<span class="ph token punctuation">[</span><span class="ph token number">4</span><span class="ph token punctuation">]</span><span class="ph token punctuation">;</span>
size_t txSize <span class="ph token operator">=</span> <span class="ph token number">4</span><span class="ph token punctuation">;</span>

<span class="ph token keyword">void</span> <span class="ph token function">APP_SPITransferHandler</span><span class="ph token punctuation">(</span>uintptr_t context<span class="ph token punctuation">)</span>
<span class="ph token punctuation">{</span>
    <span class="ph token comment">//Transfer was completed without error, do something else now.</span>
<span class="ph token punctuation">}</span>

<span class="ph token function">SERCOM0_SPI_Initialize</span><span class="ph token punctuation">(</span><span class="ph token punctuation">)</span><span class="ph token punctuation">;</span>
<span class="ph token function">SERCOM0_SPI_CallbackRegister</span><span class="ph token punctuation">(</span><span class="ph token operator">&amp;</span>APP_SPITransferHandler<span class="ph token punctuation">,</span> <span class="ph token punctuation">(</span>uintptr_t<span class="ph token punctuation">)</span><span class="ph token constant">NULL</span><span class="ph token punctuation">)</span><span class="ph token punctuation">;</span>
<span class="ph token keyword">if</span><span class="ph token punctuation">(</span><span class="ph token function">SERCOM0_SPI_Write</span><span class="ph token punctuation">(</span><span class="ph token operator">&amp;</span>txBuffer<span class="ph token punctuation">,</span> txSize<span class="ph token punctuation">)</span><span class="ph token punctuation">)</span>
<span class="ph token punctuation">{</span>
    <span class="ph token comment">// request got accepted</span>
<span class="ph token punctuation">}</span>
<span class="ph token keyword">else</span>
<span class="ph token punctuation">{</span>
    <span class="ph token comment">// request didn't get accepted, try again later with correct arguments</span>
<span class="ph token punctuation">}</span>
</code></pre><p class="p"><em class="ph i">SPI slave mode</em></p>
<pre class="pre codeblock language-c"><button title="Copy Code" class="copy-code" onclick="cpy('d725539e292', this);">Copy</button><code id="d725539e292" content="uint8_t APP_TxData[4];&#xA;uint8_t APP_RxData[10];&#xA;size_t txSize = 4;&#xA;&#xA;void SPIEventHandler(uintptr_t context )&#xA;{&#xA;    if (SERCOM0_SPI_ErrorGet() == SPI_SLAVE_ERROR_NONE)&#xA;    {&#xA;        // Read out the received data. This could be meaningful data if SPI master is&#xA;        // writing to slave or it could be dummy data if SPI master is reading from slave.&#xA;        // However, irrespective of whether slave is expecting meaningful data or dummy&#xA;        // data from master, SPI slave must always read out the data to clear the PLIB's&#xA;        // internal receive buffer.&#xA;&#xA;        appData.nBytesRead = SERCOM0_SPI_Read(APP_RxData, SERCOM0_SPI_ReadCountGet());&#xA;    }&#xA;    else&#xA;    {&#xA;        // Handle error&#xA;    }&#xA;&#xA;}&#xA;&#xA;SERCOM0_SPI_CallbackRegister(SPIEventHandler, (uintptr_t) 0);&#xA;SERCOM0_SPI_Write(APP_TxData, txSize);">uint8_t APP_TxData<span class="ph token punctuation">[</span><span class="ph token number">4</span><span class="ph token punctuation">]</span><span class="ph token punctuation">;</span>
uint8_t APP_RxData<span class="ph token punctuation">[</span><span class="ph token number">10</span><span class="ph token punctuation">]</span><span class="ph token punctuation">;</span>
size_t txSize <span class="ph token operator">=</span> <span class="ph token number">4</span><span class="ph token punctuation">;</span>

<span class="ph token keyword">void</span> <span class="ph token function">SPIEventHandler</span><span class="ph token punctuation">(</span>uintptr_t context <span class="ph token punctuation">)</span>
<span class="ph token punctuation">{</span>
    <span class="ph token keyword">if</span> <span class="ph token punctuation">(</span><span class="ph token function">SERCOM0_SPI_ErrorGet</span><span class="ph token punctuation">(</span><span class="ph token punctuation">)</span> <span class="ph token operator">==</span> SPI_SLAVE_ERROR_NONE<span class="ph token punctuation">)</span>
    <span class="ph token punctuation">{</span>
        <span class="ph token comment">// Read out the received data. This could be meaningful data if SPI master is</span>
        <span class="ph token comment">// writing to slave or it could be dummy data if SPI master is reading from slave.</span>
        <span class="ph token comment">// However, irrespective of whether slave is expecting meaningful data or dummy</span>
        <span class="ph token comment">// data from master, SPI slave must always read out the data to clear the PLIB's</span>
        <span class="ph token comment">// internal receive buffer.</span>

        appData<span class="ph token punctuation">.</span>nBytesRead <span class="ph token operator">=</span> <span class="ph token function">SERCOM0_SPI_Read</span><span class="ph token punctuation">(</span>APP_RxData<span class="ph token punctuation">,</span> <span class="ph token function">SERCOM0_SPI_ReadCountGet</span><span class="ph token punctuation">(</span><span class="ph token punctuation">)</span><span class="ph token punctuation">)</span><span class="ph token punctuation">;</span>
    <span class="ph token punctuation">}</span>
    <span class="ph token keyword">else</span>
    <span class="ph token punctuation">{</span>
        <span class="ph token comment">// Handle error</span>
    <span class="ph token punctuation">}</span>

<span class="ph token punctuation">}</span>

<span class="ph token function">SERCOM0_SPI_CallbackRegister</span><span class="ph token punctuation">(</span>SPIEventHandler<span class="ph token punctuation">,</span> <span class="ph token punctuation">(</span>uintptr_t<span class="ph token punctuation">)</span> <span class="ph token number">0</span><span class="ph token punctuation">)</span><span class="ph token punctuation">;</span>
<span class="ph token function">SERCOM0_SPI_Write</span><span class="ph token punctuation">(</span>APP_TxData<span class="ph token punctuation">,</span> txSize<span class="ph token punctuation">)</span><span class="ph token punctuation">;</span></code></pre></div>
</div>
<div class="topic nested1" aria-labelledby="ariaid-title9" id="remarks"><h2 class="title topictitle2" id="ariaid-title9">Remarks</h2><div class="body"><p class="p"><em class="ph i">SPI slave mode</em></p>
<p class="p">This function returns immediately. Application must register a callback to get notified, when the data transfer is complete. A data transfer is considered as complete, when the Chip Select line is driven to inactive state by the SPI master.</p>
</div>
</div>
</body>
</html>